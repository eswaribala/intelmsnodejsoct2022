{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst Status = require('./status');\n\nconst Semaphore = require('./semaphore');\n\nconst STATE = Symbol('state');\nconst OPEN = Symbol('open');\nconst CLOSED = Symbol('closed');\nconst HALF_OPEN = Symbol('half-open');\nconst PENDING_CLOSE = Symbol('pending-close');\nconst SHUTDOWN = Symbol('shutdown');\nconst FALLBACK_FUNCTION = Symbol('fallback');\nconst STATUS = Symbol('status');\nconst NAME = Symbol('name');\nconst GROUP = Symbol('group');\nconst CACHE = new WeakMap();\nconst ENABLED = Symbol('Enabled');\nconst WARMING_UP = Symbol('warming-up');\nconst VOLUME_THRESHOLD = Symbol('volume-threshold');\nconst OUR_ERROR = Symbol('our-error');\nconst RESET_TIMEOUT = Symbol('reset-timeout');\nconst WARMUP_TIMEOUT = Symbol('warmup-timeout');\nconst deprecation = `options.maxFailures is deprecated. \\\nPlease use options.errorThresholdPercentage`;\n/**\n * Constructs a {@link CircuitBreaker}.\n *\n * @class CircuitBreaker\n * @extends EventEmitter\n * @param {Function} action The action to fire for this {@link CircuitBreaker}\n * @param {Object} options Options for the {@link CircuitBreaker}\n * @param {Status} options.status A {@link Status} object that might\n *   have pre-prime stats\n * @param {Number} options.timeout The time in milliseconds that action should\n * be allowed to execute before timing out. Timeout can be disabled by setting\n * this to `false`. Default 10000 (10 seconds)\n * @param {Number} options.maxFailures (Deprecated) The number of times the\n * circuit can fail before opening. Default 10.\n * @param {Number} options.resetTimeout The time in milliseconds to wait before\n * setting the breaker to `halfOpen` state, and trying the action again.\n * Default: 30000 (30 seconds)\n * @param {Number} options.rollingCountTimeout Sets the duration of the\n * statistical rolling window, in milliseconds. This is how long Opossum keeps\n * metrics for the circuit breaker to use and for publishing. Default: 10000\n * @param {Number} options.rollingCountBuckets Sets the number of buckets the\n * rolling statistical window is divided into. So, if\n * options.rollingCountTimeout is 10000, and options.rollingCountBuckets is 10,\n * then the statistical window will be 1000/1 second snapshots in the\n * statistical window. Default: 10\n * @param {String} options.name the circuit name to use when reporting stats.\n * Default: the name of the function this circuit controls.\n * @param {boolean} options.rollingPercentilesEnabled This property indicates\n * whether execution latencies should be tracked and calculated as percentiles.\n * If they are disabled, all summary statistics (mean, percentiles) are\n * returned as -1. Default: true\n * @param {Number} options.capacity the number of concurrent requests allowed.\n * If the number currently executing function calls is equal to\n * options.capacity, further calls to `fire()` are rejected until at least one\n * of the current requests completes. Default: `Number.MAX_SAFE_INTEGER`.\n * @param {Number} options.errorThresholdPercentage the error percentage at\n * which to open the circuit and start short-circuiting requests to fallback.\n * Default: 50\n * @param {boolean} options.enabled whether this circuit is enabled upon\n * construction. Default: true\n * @param {boolean} options.allowWarmUp determines whether to allow failures\n * without opening the circuit during a brief warmup period (this is the\n * `rollingCountTimeout` property). Default: false\n * This can help in situations where no matter what your\n * `errorThresholdPercentage` is, if the first execution times out or fails,\n * the circuit immediately opens.\n * @param {Number} options.volumeThreshold the minimum number of requests within\n * the rolling statistical window that must exist before the circuit breaker\n * can open. This is similar to `options.allowWarmUp` in that no matter how many\n * failures there are, if the number of requests within the statistical window\n * does not exceed this threshold, the circuit will remain closed. Default: 0\n * @param {Function} options.errorFilter an optional function that will be\n * called when the circuit's function fails (returns a rejected Promise). If\n * this function returns truthy, the circuit's failPure statistics will not be\n * incremented. This is useful, for example, when you don't want HTTP 404 to\n * trip the circuit, but still want to handle it as a failure case.\n * @param {boolean} options.cache whether the return value of the first\n * successful execution of the circuit's function will be cached. Once a value\n * has been cached that value will be returned for every subsequent execution:\n * the cache can be cleared using `clearCache`. (The metrics `cacheHit` and\n * `cacheMiss` reflect cache activity.) Default: false\n *\n *\n * @fires CircuitBreaker#halfOpen\n * @fires CircuitBreaker#close\n * @fires CircuitBreaker#open\n * @fires CircuitBreaker#fire\n * @fires CircuitBreaker#cacheHit\n * @fires CircuitBreaker#cacheMiss\n * @fires CircuitBreaker#reject\n * @fires CircuitBreaker#timeout\n * @fires CircuitBreaker#success\n * @fires CircuitBreaker#semaphoreLocked\n * @fires CircuitBreaker#healthCheckFailed\n * @fires CircuitBreaker#fallback\n * @fires CircuitBreaker#failure\n */\n\nclass CircuitBreaker extends EventEmitter {\n  /**\n   * Returns true if the provided error was generated here. It will be false\n   * if the error came from the action itself.\n   * @param {Error} error The Error to check.\n   * @returns {Boolean} true if the error was generated here\n   */\n  static isOurError(error) {\n    return !!error[OUR_ERROR];\n  }\n  /**\n  * Create a new Status object,\n  * helpful when you need to prime a breaker with stats\n  * @param {Object} options -\n  * @param {Number} options.rollingCountBuckets number of buckets in the window\n  * @param {Number} options.rollingCountTimeout the duration of the window\n  * @param {Boolean} options.rollingPercentilesEnabled whether to calculate\n  * @param {Object} options.stats user supplied stats\n  * @returns {Status} a new {@link Status} object\n  */\n\n\n  static newStatus(options) {\n    return new Status(options);\n  }\n\n  constructor(action, options = {}) {\n    super();\n    this.options = options;\n    this.options.timeout = options.timeout === false ? false : options.timeout || 10000;\n    this.options.resetTimeout = options.resetTimeout || 30000;\n    this.options.errorThresholdPercentage = options.errorThresholdPercentage || 50;\n    this.options.rollingCountTimeout = options.rollingCountTimeout || 10000;\n    this.options.rollingCountBuckets = options.rollingCountBuckets || 10;\n    this.options.rollingPercentilesEnabled = options.rollingPercentilesEnabled !== false;\n    this.options.capacity = Number.isInteger(options.capacity) ? options.capacity : Number.MAX_SAFE_INTEGER;\n\n    this.options.errorFilter = options.errorFilter || (_ => false);\n\n    this.semaphore = new Semaphore(this.options.capacity); // check if action is defined\n\n    if (!action) {\n      throw new TypeError('No action provided. Cannot construct a CircuitBreaker without an invocable action.');\n    }\n\n    this[VOLUME_THRESHOLD] = Number.isInteger(options.volumeThreshold) ? options.volumeThreshold : 0;\n    this[WARMING_UP] = options.allowWarmUp === true; // The user can pass in a Status object to initialize the Status/stats\n\n    if (this.options.status) {\n      // Do a check that this is a Status Object,\n      if (this.options.status instanceof Status) {\n        this[STATUS] = this.options.status;\n      } else {\n        this[STATUS] = new Status({\n          stats: this.options.status\n        });\n      }\n    } else {\n      this[STATUS] = new Status(this.options);\n    }\n\n    this[STATE] = CLOSED;\n\n    if (options.state) {\n      this[ENABLED] = options.state.enabled !== false;\n      this[WARMING_UP] = options.state.warmUp || this[WARMING_UP]; // Closed if nothing is passed in\n\n      this[CLOSED] = options.state.closed !== false; // These should be in sync\n\n      this[HALF_OPEN] = this[PENDING_CLOSE] = options.state.halfOpen || false; // Open should be the opposite of closed,\n      // but also the opposite of half_open\n\n      this[OPEN] = !this[CLOSED] && !this[HALF_OPEN];\n      this[SHUTDOWN] = options.state.shutdown || false;\n    } else {\n      this[PENDING_CLOSE] = false;\n      this[ENABLED] = options.enabled !== false;\n    }\n\n    this[FALLBACK_FUNCTION] = null;\n    this[NAME] = options.name || action.name || nextName();\n    this[GROUP] = options.group || this[NAME];\n\n    if (this[WARMING_UP]) {\n      const timer = this[WARMUP_TIMEOUT] = setTimeout(_ => this[WARMING_UP] = false, this.options.rollingCountTimeout);\n\n      if (typeof timer.unref === 'function') {\n        timer.unref();\n      }\n    }\n\n    if (typeof action !== 'function') {\n      this.action = _ => Promise.resolve(action);\n    } else this.action = action;\n\n    if (options.maxFailures) console.error(deprecation);\n\n    const increment = property => (result, runTime) => this[STATUS].increment(property, runTime);\n\n    this.on('success', increment('successes'));\n    this.on('failure', increment('failures'));\n    this.on('fallback', increment('fallbacks'));\n    this.on('timeout', increment('timeouts'));\n    this.on('fire', increment('fires'));\n    this.on('reject', increment('rejects'));\n    this.on('cacheHit', increment('cacheHits'));\n    this.on('cacheMiss', increment('cacheMisses'));\n    this.on('open', _ => this[STATUS].open());\n    this.on('close', _ => this[STATUS].close());\n    this.on('semaphoreLocked', increment('semaphoreRejections'));\n    /**\n     * @param {CircuitBreaker} circuit This current circuit\n     * @returns {function(): void} A bound reset callback\n     * @private\n     */\n\n    function _startTimer(circuit) {\n      return _ => {\n        const timer = circuit[RESET_TIMEOUT] = setTimeout(() => {\n          circuit[STATE] = HALF_OPEN;\n          circuit[PENDING_CLOSE] = true;\n          /**\n           * Emitted after `options.resetTimeout` has elapsed, allowing for\n           * a single attempt to call the service again. If that attempt is\n           * successful, the circuit will be closed. Otherwise it remains open.\n           *\n           * @event CircuitBreaker#halfOpen\n           * @type {Number} how long the circuit remained open\n           */\n\n          circuit.emit('halfOpen', circuit.options.resetTimeout);\n        }, circuit.options.resetTimeout);\n\n        if (typeof timer.unref === 'function') {\n          timer.unref();\n        }\n      };\n    }\n\n    this.on('open', _startTimer(this));\n    this.on('success', _ => {\n      if (this.halfOpen) {\n        this.close();\n      }\n    });\n\n    if (this.options.cache) {\n      CACHE.set(this, undefined);\n    } // Prepopulate the State of the Breaker\n\n\n    if (this[SHUTDOWN]) {\n      this[STATE] = SHUTDOWN;\n      this.shutdown();\n    } else if (this[CLOSED]) {\n      this.close();\n    } else if (this[OPEN]) {\n      // If the state being passed in is OPEN\n      // THen we need to start some timers\n      this.open();\n    } else if (this[HALF_OPEN]) {\n      // Not sure if anything needs to be done here\n      this[STATE] = HALF_OPEN;\n    }\n  }\n  /**\n   * Closes the breaker, allowing the action to execute again\n   * @fires CircuitBreaker#close\n   * @returns {void}\n   */\n\n\n  close() {\n    if (this[STATE] !== CLOSED) {\n      if (this[RESET_TIMEOUT]) {\n        clearTimeout(this[RESET_TIMEOUT]);\n      }\n\n      this[STATE] = CLOSED;\n      this[PENDING_CLOSE] = false;\n      /**\n       * Emitted when the breaker is reset allowing the action to execute again\n       * @event CircuitBreaker#close\n       */\n\n      this.emit('close');\n    }\n  }\n  /**\n   * Opens the breaker. Each time the breaker is fired while the circuit is\n   * opened, a failed Promise is returned, or if any fallback function\n   * has been provided, it is invoked.\n   *\n   * If the breaker is already open this call does nothing.\n   * @fires CircuitBreaker#open\n   * @returns {void}\n   */\n\n\n  open() {\n    if (this[STATE] !== OPEN) {\n      this[STATE] = OPEN;\n      this[PENDING_CLOSE] = false;\n      /**\n       * Emitted when the breaker opens because the action has\n       * failed more than `options.maxFailures` number of times.\n       * @event CircuitBreaker#open\n       */\n\n      this.emit('open');\n    }\n  }\n  /**\n   * Shuts down this circuit breaker. All subsequent calls to the\n   * circuit will fail, returning a rejected promise.\n   * @returns {void}\n   */\n\n\n  shutdown() {\n    /**\n     * Emitted when the circuit breaker has been shut down.\n     * @event CircuitBreaker#shutdown\n     */\n    this.emit('shutdown');\n    this.disable();\n    this.removeAllListeners();\n\n    if (this[RESET_TIMEOUT]) {\n      clearTimeout(this[RESET_TIMEOUT]);\n    }\n\n    if (this[WARMUP_TIMEOUT]) {\n      clearTimeout(this[WARMUP_TIMEOUT]);\n    }\n\n    this.status.shutdown();\n    this[STATE] = SHUTDOWN;\n  }\n  /**\n   * Determines if the circuit has been shutdown.\n   * @type {Boolean}\n   */\n\n\n  get isShutdown() {\n    return this[STATE] === SHUTDOWN;\n  }\n  /**\n   * Gets the name of this circuit\n   * @type {String}\n   */\n\n\n  get name() {\n    return this[NAME];\n  }\n  /**\n   * Gets the name of this circuit group\n   * @type {String}\n   */\n\n\n  get group() {\n    return this[GROUP];\n  }\n  /**\n   * Gets whether this circuit is in the `pendingClosed` state\n   * @type {Boolean}\n   */\n\n\n  get pendingClose() {\n    return this[PENDING_CLOSE];\n  }\n  /**\n   * True if the circuit is currently closed. False otherwise.\n   * @type {Boolean}\n   */\n\n\n  get closed() {\n    return this[STATE] === CLOSED;\n  }\n  /**\n   * True if the circuit is currently opened. False otherwise.\n   * @type {Boolean}\n   */\n\n\n  get opened() {\n    return this[STATE] === OPEN;\n  }\n  /**\n   * True if the circuit is currently half opened. False otherwise.\n   * @type {Boolean}\n   */\n\n\n  get halfOpen() {\n    return this[STATE] === HALF_OPEN;\n  }\n  /**\n   * The current {@link Status} of this {@link CircuitBreaker}\n   * @type {Status}\n   */\n\n\n  get status() {\n    return this[STATUS];\n  }\n  /**\n   * Get the current stats for the circuit.\n   * @see Status#stats\n   * @type {Object}\n   */\n\n\n  get stats() {\n    return this[STATUS].stats;\n  }\n\n  toJSON() {\n    return {\n      state: {\n        name: this.name,\n        enabled: this.enabled,\n        closed: this.closed,\n        open: this.opened,\n        halfOpen: this.halfOpen,\n        warmUp: this.warmUp,\n        shutdown: this.isShutdown\n      },\n      status: this.status.stats\n    };\n  }\n  /**\n   * Gets whether the circuit is enabled or not\n   * @type {Boolean}\n   */\n\n\n  get enabled() {\n    return this[ENABLED];\n  }\n  /**\n   * Gets whether the circuit is currently in warm up phase\n   * @type {Boolean}\n   */\n\n\n  get warmUp() {\n    return this[WARMING_UP];\n  }\n  /**\n   * Gets the volume threshold for this circuit\n   * @type {Boolean}\n   */\n\n\n  get volumeThreshold() {\n    return this[VOLUME_THRESHOLD];\n  }\n  /**\n   * Provide a fallback function for this {@link CircuitBreaker}. This\n   * function will be executed when the circuit is `fire`d and fails.\n   * It will always be preceded by a `failure` event, and `breaker.fire` returns\n   * a rejected Promise.\n   * @param {Function | CircuitBreaker} func the fallback function to execute\n   * when the breaker has opened or when a timeout or error occurs.\n   * @return {CircuitBreaker} this\n   */\n\n\n  fallback(func) {\n    let fb = func;\n\n    if (func instanceof CircuitBreaker) {\n      fb = function () {\n        return func.fire.apply(func, arguments);\n      };\n    }\n\n    this[FALLBACK_FUNCTION] = fb;\n    return this;\n  }\n  /**\n   * Execute the action for this circuit. If the action fails or times out, the\n   * returned promise will be rejected. If the action succeeds, the promise will\n   * resolve with the resolved value from action. If a fallback function was\n   * provided, it will be invoked in the event of any failure or timeout.\n   *\n   * Any parameters passed to this function will be proxied to the circuit\n   * function.\n   *\n   * @return {Promise<any>} promise resolves with the circuit function's return\n   * value on success or is rejected on failure of the action. Use isOurError()\n   * to determine if a rejection was a result of the circuit breaker or the\n   * action.\n   *\n   * @fires CircuitBreaker#failure\n   * @fires CircuitBreaker#fallback\n   * @fires CircuitBreaker#fire\n   * @fires CircuitBreaker#reject\n   * @fires CircuitBreaker#success\n   * @fires CircuitBreaker#timeout\n   * @fires CircuitBreaker#semaphoreLocked\n   */\n\n\n  fire(...args) {\n    return this.call.apply(this, [this.action].concat(args));\n  }\n  /**\n   * Execute the action for this circuit using `context` as `this`.\n   * If the action fails or times out, the\n   * returned promise will be rejected. If the action succeeds, the promise will\n   * resolve with the resolved value from action. If a fallback function was\n   * provided, it will be invoked in the event of any failure or timeout.\n   *\n   * Any parameters in addition to `context will be passed to the\n   * circuit function.\n   *\n   * @param {any} context the `this` context used for function execution\n   * @param {any} rest the arguments passed to the action\n   *\n   * @return {Promise<any>} promise resolves with the circuit function's return\n   * value on success or is rejected on failure of the action.\n   *\n   * @fires CircuitBreaker#failure\n   * @fires CircuitBreaker#fallback\n   * @fires CircuitBreaker#fire\n   * @fires CircuitBreaker#reject\n   * @fires CircuitBreaker#success\n   * @fires CircuitBreaker#timeout\n   * @fires CircuitBreaker#semaphoreLocked\n   */\n\n\n  call(context, ...rest) {\n    if (this.isShutdown) {\n      const err = buildError('The circuit has been shutdown.', 'ESHUTDOWN');\n      return Promise.reject(err);\n    }\n\n    const args = Array.prototype.slice.call(rest);\n    /**\n     * Emitted when the circuit breaker action is executed\n     * @event CircuitBreaker#fire\n     * @type {any} the arguments passed to the fired function\n     */\n\n    this.emit('fire', args);\n\n    if (CACHE.get(this) !== undefined) {\n      /**\n       * Emitted when the circuit breaker is using the cache\n       * and finds a value.\n       * @event CircuitBreaker#cacheHit\n       */\n      this.emit('cacheHit');\n      return CACHE.get(this);\n    } else if (this.options.cache) {\n      /**\n       * Emitted when the circuit breaker does not find a value in\n       * the cache, but the cache option is enabled.\n       * @event CircuitBreaker#cacheMiss\n       */\n      this.emit('cacheMiss');\n    }\n\n    if (!this[ENABLED]) {\n      const result = this.action.apply(context, args);\n      return typeof result.then === 'function' ? result : Promise.resolve(result);\n    }\n\n    if (!this.closed && !this.pendingClose) {\n      /**\n       * Emitted when the circuit breaker is open and failing fast\n       * @event CircuitBreaker#reject\n       * @type {Error}\n       */\n      const error = buildError('Breaker is open', 'EOPENBREAKER');\n      this.emit('reject', error);\n      return fallback(this, error, args) || Promise.reject(error);\n    }\n\n    this[PENDING_CLOSE] = false;\n    let timeout;\n    let timeoutError = false;\n    return new Promise((resolve, reject) => {\n      const latencyStartTime = Date.now();\n\n      if (this.semaphore.test()) {\n        if (this.options.timeout) {\n          timeout = setTimeout(() => {\n            timeoutError = true;\n            const error = buildError(`Timed out after ${this.options.timeout}ms`, 'ETIMEDOUT');\n            const latency = Date.now() - latencyStartTime;\n            this.semaphore.release();\n            /**\n             * Emitted when the circuit breaker action takes longer than\n             * `options.timeout`\n             * @event CircuitBreaker#timeout\n             * @type {Error}\n             */\n\n            this.emit('timeout', error, latency, args);\n            handleError(error, this, timeout, args, latency, resolve, reject);\n          }, this.options.timeout);\n        }\n\n        try {\n          const result = this.action.apply(context, args);\n          const promise = typeof result.then === 'function' ? result : Promise.resolve(result);\n          promise.then(result => {\n            if (!timeoutError) {\n              clearTimeout(timeout);\n              /**\n               * Emitted when the circuit breaker action succeeds\n               * @event CircuitBreaker#success\n               * @type {any} the return value from the circuit\n               */\n\n              this.emit('success', result, Date.now() - latencyStartTime);\n              this.semaphore.release();\n              resolve(result);\n\n              if (this.options.cache) {\n                CACHE.set(this, promise);\n              }\n            }\n          }).catch(error => {\n            if (!timeoutError) {\n              this.semaphore.release();\n              const latencyEndTime = Date.now() - latencyStartTime;\n              handleError(error, this, timeout, args, latencyEndTime, resolve, reject);\n            }\n          });\n        } catch (error) {\n          this.semaphore.release();\n          const latency = Date.now() - latencyStartTime;\n          handleError(error, this, timeout, args, latency, resolve, reject);\n        }\n      } else {\n        const latency = Date.now() - latencyStartTime;\n        const err = buildError('Semaphore locked', 'ESEMLOCKED');\n        /**\n         * Emitted when the rate limit has been reached and there\n         * are no more locks to be obtained.\n         * @event CircuitBreaker#semaphoreLocked\n         * @type {Error}\n         */\n\n        this.emit('semaphoreLocked', err, latency);\n        handleError(err, this, timeout, args, latency, resolve, reject);\n      }\n    });\n  }\n  /**\n   * Clears the cache of this {@link CircuitBreaker}\n   * @returns {void}\n   */\n\n\n  clearCache() {\n    CACHE.set(this, undefined);\n  }\n  /**\n   * Provide a health check function to be called periodically. The function\n   * should return a Promise. If the promise is rejected the circuit will open.\n   * This is in addition to the existing circuit behavior as defined by\n   * `options.errorThresholdPercentage` in the constructor. For example, if the\n   * health check function provided here always returns a resolved promise, the\n   * circuit can still trip and open if there are failures exceeding the\n   * configured threshold. The health check function is executed within the\n   * circuit breaker's execution context, so `this` within the function is the\n   * circuit breaker itself.\n   *\n   * @param {Function} func a health check function which returns a promise.\n   * @param {Number} [interval] the amount of time between calls to the health\n   * check function. Default: 5000 (5 seconds)\n   *\n   * @returns {void}\n   *\n   * @fires CircuitBreaker#healthCheckFailed\n   * @throws {TypeError} if `interval` is supplied but not a number\n   */\n\n\n  healthCheck(func, interval) {\n    interval = interval || 5000;\n\n    if (typeof func !== 'function') {\n      throw new TypeError('Health check function must be a function');\n    }\n\n    if (isNaN(interval)) {\n      throw new TypeError('Health check interval must be a number');\n    }\n\n    const check = _ => {\n      func.apply(this).catch(e => {\n        /**\n         * Emitted with the user-supplied health check function\n         * returns a rejected promise.\n         * @event CircuitBreaker#healthCheckFailed\n         * @type {Error}\n         */\n        this.emit('healthCheckFailed', e);\n        this.open();\n      });\n    };\n\n    const timer = setInterval(check, interval);\n\n    if (typeof timer.unref === 'function') {\n      timer.unref();\n    }\n\n    check();\n  }\n  /**\n   * Enables this circuit. If the circuit is the  disabled\n   * state, it will be re-enabled. If not, this is essentially\n   * a noop.\n   * @returns {void}\n   */\n\n\n  enable() {\n    this[ENABLED] = true;\n  }\n  /**\n   * Disables this circuit, causing all calls to the circuit's function\n   * to be executed without circuit or fallback protection.\n   * @returns {void}\n   */\n\n\n  disable() {\n    this[ENABLED] = false;\n  }\n\n}\n\nfunction handleError(error, circuit, timeout, args, latency, resolve, reject) {\n  clearTimeout(timeout);\n\n  if (circuit.options.errorFilter(error, ...args)) {\n    // The error was filtered, so emit 'success'\n    circuit.emit('success', error, latency);\n  } else {\n    // Error was not filtered, so emit 'failure'\n    fail(circuit, error, args, latency); // Only call the fallback function if errorFilter doesn't succeed\n    // If the fallback function succeeds, resolve\n\n    const fb = fallback(circuit, error, args);\n    if (fb) return resolve(fb);\n  } // In all other cases, reject\n\n\n  reject(error);\n}\n\nfunction fallback(circuit, err, args) {\n  if (circuit[FALLBACK_FUNCTION]) {\n    try {\n      const result = circuit[FALLBACK_FUNCTION].apply(circuit[FALLBACK_FUNCTION], [...args, err]);\n      /**\n       * Emitted when the circuit breaker executes a fallback function\n       * @event CircuitBreaker#fallback\n       * @type {any} the return value of the fallback function\n       */\n\n      circuit.emit('fallback', result, err);\n      if (result instanceof Promise) return result;\n      return Promise.resolve(result);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n}\n\nfunction fail(circuit, err, args, latency) {\n  /**\n   * Emitted when the circuit breaker action fails\n   * @event CircuitBreaker#failure\n   * @type {Error}\n   */\n  circuit.emit('failure', err, latency, args);\n  if (circuit.warmUp) return; // check stats to see if the circuit should be opened\n\n  const stats = circuit.stats;\n  if (stats.fires < circuit.volumeThreshold && !circuit.halfOpen) return;\n  const errorRate = stats.failures / stats.fires * 100;\n\n  if (errorRate > circuit.options.errorThresholdPercentage || stats.failures >= circuit.options.maxFailures || circuit.halfOpen) {\n    circuit.open();\n  }\n}\n\nfunction buildError(msg, code) {\n  const error = new Error(msg);\n  error.code = code;\n  error[OUR_ERROR] = true;\n  return error;\n} // http://stackoverflow.com/a/2117523\n\n\nconst nextName = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n  const r = Math.random() * 16 | 0;\n  const v = c === 'x' ? r : r & 0x3 | 0x8;\n  return v.toString(16);\n});\n\nmodule.exports = exports = CircuitBreaker;","map":null,"metadata":{},"sourceType":"script"}
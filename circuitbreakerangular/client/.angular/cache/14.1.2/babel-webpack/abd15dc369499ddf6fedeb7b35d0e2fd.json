{"ast":null,"code":"'use strict';\n\nconst WINDOW = Symbol('window');\nconst BUCKETS = Symbol('buckets');\nconst TIMEOUT = Symbol('timeout');\nconst PERCENTILES = Symbol('percentiles');\nconst BUCKET_INTERVAL = Symbol('bucket-interval');\nconst SNAPSHOT_INTERVAL = Symbol('snapshot-interval');\n\nconst EventEmitter = require('events').EventEmitter;\n/**\n * Tracks execution status for a given {@link CircuitBreaker}.\n * A Status instance is created for every {@link CircuitBreaker}\n * and does not typically need to be created by a user.\n *\n * A Status instance will listen for all events on the {@link CircuitBreaker}\n * and track them in a rolling statistical window. The window duration is\n * determined by the `rollingCountTimeout` option provided to the\n * {@link CircuitBreaker}. The window consists of an array of Objects,\n * each representing the counts for a {@link CircuitBreaker}'s events.\n *\n * The array's length is determined by the {@link CircuitBreaker}'s\n * `rollingCountBuckets` option. The duration of each slice of the window\n * is determined by dividing the `rollingCountTimeout` by\n * `rollingCountBuckets`.\n *\n * @class Status\n * @extends EventEmitter\n * @param {Object} options for the status window\n * @param {Number} options.rollingCountBuckets number of buckets in the window\n * @param {Number} options.rollingCountTimeout the duration of the window\n * @param {Boolean} options.rollingPercentilesEnabled whether to calculate\n * percentiles\n * @param {Object} options.stats object of previous stats\n * @example\n * // Creates a 1 second window consisting of ten time slices,\n * // each 100ms long.\n * const circuit = circuitBreaker(fs.readFile,\n *  { rollingCountBuckets: 10, rollingCountTimeout: 1000});\n *\n * // get the cumulative statistics for the last second\n * circuit.status.stats;\n *\n * // get the array of 10, 1 second time slices for the last second\n * circuit.status.window;\n * @fires Status#snapshot\n * @see CircuitBreaker#status\n */\n\n\nclass Status extends EventEmitter {\n  constructor(options) {\n    super(); // Set up our statistical rolling window\n\n    this[BUCKETS] = options.rollingCountBuckets || 10;\n    this[TIMEOUT] = options.rollingCountTimeout || 10000;\n    this[WINDOW] = new Array(this[BUCKETS]);\n    this[PERCENTILES] = [0.0, 0.25, 0.5, 0.75, 0.9, 0.95, 0.99, 0.995, 1]; // Default this value to true\n\n    this.rollingPercentilesEnabled = options.rollingPercentilesEnabled !== false; // prime the window with buckets\n\n    for (let i = 0; i < this[BUCKETS]; i++) this[WINDOW][i] = bucket(); // rotate the buckets periodically\n\n\n    const bucketInterval = Math.floor(this[TIMEOUT] / this[BUCKETS]);\n    this[BUCKET_INTERVAL] = setInterval(nextBucket(this[WINDOW]), bucketInterval); // No unref() in the browser\n\n    if (typeof this[BUCKET_INTERVAL].unref === 'function') {\n      this[BUCKET_INTERVAL].unref();\n    }\n    /**\n     * Emitted at each time-slice. Listeners for this\n     * event will receive a cumulative snapshot of the current status window.\n     * @event Status#snapshot\n     * @type {Object}\n     */\n\n\n    this[SNAPSHOT_INTERVAL] = setInterval(_ => this.emit('snapshot', this.stats), bucketInterval);\n\n    if (typeof this[SNAPSHOT_INTERVAL].unref === 'function') {\n      this[SNAPSHOT_INTERVAL].unref();\n    }\n\n    if (options.stats) {\n      this[WINDOW][0] = { ...bucket(),\n        ...options.stats\n      };\n    }\n  }\n  /**\n   * Get the cumulative stats for the current window\n   * @type {Object}\n   */\n\n\n  get stats() {\n    const totals = this[WINDOW].reduce((acc, val) => {\n      if (!val) {\n        return acc;\n      }\n\n      Object.keys(acc).forEach(key => {\n        if (key !== 'latencyTimes' && key !== 'percentiles') {\n          acc[key] += val[key] || 0;\n        }\n      });\n\n      if (this.rollingPercentilesEnabled) {\n        acc.latencyTimes.push.apply(acc.latencyTimes, val.latencyTimes || []);\n      }\n\n      return acc;\n    }, bucket());\n\n    if (this.rollingPercentilesEnabled) {\n      // Sort the latencyTimes\n      totals.latencyTimes.sort((a, b) => a - b); // Get the mean latency\n      // Mean = sum of all values in the array/length of array\n\n      if (totals.latencyTimes.length) {\n        totals.latencyMean = totals.latencyTimes.reduce((a, b) => a + b, 0) / totals.latencyTimes.length;\n      } else {\n        totals.latencyMean = 0;\n      } // Calculate Percentiles\n\n\n      this[PERCENTILES].forEach(percentile => {\n        totals.percentiles[percentile] = calculatePercentile(percentile, totals.latencyTimes);\n      });\n    } else {\n      totals.latencyMean = -1;\n      this[PERCENTILES].forEach(percentile => {\n        totals.percentiles[percentile] = -1;\n      });\n    }\n\n    return totals;\n  }\n  /**\n   * Gets the stats window as an array of time-sliced objects.\n   * @type {Array}\n   */\n\n\n  get window() {\n    return this[WINDOW].slice();\n  }\n\n  increment(property, latencyRunTime) {\n    this[WINDOW][0][property]++;\n\n    if (property === 'successes' || property === 'failures' || property === 'timeouts') {\n      this[WINDOW][0].latencyTimes.push(latencyRunTime || 0);\n    }\n  }\n\n  open() {\n    this[WINDOW][0].isCircuitBreakerOpen = true;\n  }\n\n  close() {\n    this[WINDOW][0].isCircuitBreakerOpen = false;\n  }\n\n  shutdown() {\n    this.removeAllListeners();\n    clearInterval(this[BUCKET_INTERVAL]);\n    clearInterval(this[SNAPSHOT_INTERVAL]);\n  }\n\n}\n\nconst nextBucket = window => _ => {\n  window.pop();\n  window.unshift(bucket());\n};\n\nconst bucket = _ => ({\n  failures: 0,\n  fallbacks: 0,\n  successes: 0,\n  rejects: 0,\n  fires: 0,\n  timeouts: 0,\n  cacheHits: 0,\n  cacheMisses: 0,\n  semaphoreRejections: 0,\n  percentiles: {},\n  latencyTimes: []\n});\n\nfunction calculatePercentile(percentile, arr) {\n  if (percentile === 0) {\n    return arr[0] || 0;\n  }\n\n  const idx = Math.ceil(percentile * arr.length);\n  return arr[idx - 1] || 0;\n}\n\nmodule.exports = exports = Status;","map":null,"metadata":{},"sourceType":"script"}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BatchExporter {
    constructor(exporter, bufferSize, bufferTimeout) {
        this.exporter = exporter;
        this.bufferSize = bufferSize;
        this.bufferTimeout = bufferTimeout;
        this.batchedSpans = [];
        this.ongoingExports = new Set();
    }
    /**
     * Add the span to a batch which will be sent
     *
     * @param {ReadableSpan} span
     * @memberof BatchExporter
     */
    exportSpan(span) {
        this.batchedSpans.push(span);
        this.maybeStartTimer();
        if (this.batchedSpans.length >= this.bufferSize) {
            this.flush();
        }
    }
    async forceFlush() {
        this.flush();
        await Promise.all([...this.ongoingExports]);
    }
    async shutdown() {
        await this.exporter.shutdown();
    }
    maybeStartTimer() {
        if (this.timerId !== undefined)
            return;
        this.timerId = setTimeout(() => {
            this.flush();
        }, this.bufferTimeout);
        this.timerId.unref();
    }
    flush() {
        this.clearTimer();
        if (this.batchedSpans.length === 0) {
            return Promise.resolve();
        }
        const promise = new Promise((resolve) => {
            const batchToSend = this.batchedSpans;
            this.batchedSpans = [];
            this.exporter.export(batchToSend, (_result) => {
                // consider to implement retry here
                this.ongoingExports.delete(promise);
                resolve();
            });
        });
        this.ongoingExports.add(promise);
        return promise;
    }
    clearTimer() {
        if (this.timerId !== undefined) {
            clearTimeout(this.timerId);
            this.timerId = undefined;
        }
    }
}
exports.default = BatchExporter;
//# sourceMappingURL=BatchExporter.js.map
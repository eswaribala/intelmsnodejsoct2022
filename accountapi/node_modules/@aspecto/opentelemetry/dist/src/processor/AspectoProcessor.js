"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AspectoProcessor = void 0;
const api_1 = require("@opentelemetry/api");
const core_1 = require("@opentelemetry/core");
const debug_1 = __importDefault(require("debug"));
const PrivacyEngine_1 = require("../privacy-rules/PrivacyEngine");
const ActionResult_1 = require("../privacy-rules/ActionResult");
const BatchExporter_1 = __importDefault(require("./BatchExporter"));
const logging_1 = require("../utils/logging");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const config_1 = require("../config");
const logDebugExport = debug_1.default(logging_1.SPANS_EXPORT_NS);
class AspectoProcessor {
    constructor() {
        this._exporters = [];
        this.pendingInitSpans = [];
        this.pendingInitSpansCurrSize = 0;
        const maxPendingInitSpansMb = process.env.MAX_PENDING_INIT_SPANS_MB || 10;
        this.maxPendingInitSpansBytes = maxPendingInitSpansMb * 1024 * 1024;
        this.privacyEnginePromise = new Promise((resolve) => {
            this.resolvePrivacyEngine = resolve;
        });
    }
    setBatchExporter(exporter, bufferSize, bufferTimeout) {
        if (this.batchExporter)
            return;
        this.batchExporter = new BatchExporter_1.default(exporter, bufferSize, bufferTimeout);
    }
    addExporter(exporter) {
        this._exporters.push(exporter);
    }
    newDataCollectionRules(rules, mode) {
        if (this.privacyEngine) {
            this.privacyEngine.setRules(rules, mode);
            return;
        }
        try {
            this.privacyEngine = new PrivacyEngine_1.PrivacyEngine();
            this.privacyEngine.setRules(rules, mode);
            this.pendingInitSpans.forEach((pendingInitSpan) => this.validateAndExport(pendingInitSpan.span));
        }
        catch (_a) {
            this.privacyEngine = null;
        }
        finally {
            this.pendingInitSpans = [];
            this.pendingInitSpansCurrSize = 0;
            this.resolvePrivacyEngine();
        }
    }
    async forceFlush() {
        await this.privacyEnginePromise;
        if (this.batchExporter)
            await api_1.context.with(core_1.suppressTracing(api_1.context.active()), () => this.batchExporter.forceFlush());
    }
    onStart(_span) { }
    onEnd(span) {
        if (AspectoProcessor.shouldIgnoreInternalAspectoSpans(span)) {
            logDebugExport('ignoring internal Aspecto span');
            return;
        }
        if (!this.privacyEngine) {
            logDebugExport('Pushing span to pending buffer: %O', logging_1.spanLogDetails(span));
            this.pushSpanToPendingInit(span);
        }
        else
            this.validateAndExport(span);
    }
    async shutdown() {
        await this.forceFlush();
        const shutdownPromises = this._exporters.map((exporter) => exporter.shutdown());
        if (this.batchExporter) {
            shutdownPromises.push(this.batchExporter.shutdown());
        }
        await Promise.all(shutdownPromises);
    }
    pushSpanToPendingInit(span) {
        const currSpanSize = JSON.stringify(span.attributes).length;
        this.pendingInitSpansCurrSize += currSpanSize;
        while (this.pendingInitSpans.length > 0 && this.pendingInitSpansCurrSize >= this.maxPendingInitSpansBytes) {
            this.pendingInitSpansCurrSize -= this.pendingInitSpans[0].sizeBytes;
            this.pendingInitSpans.shift();
        }
        this.pendingInitSpans.push({ sizeBytes: currSpanSize, span });
    }
    validateAndExport(span) {
        try {
            const actionResult = this.privacyEngine.executeRules(span);
            if (actionResult === ActionResult_1.ActionResult.BlockRequest) {
                logDebugExport('Span blocked by privacy rules: %O', logging_1.spanLogDetails(span));
                return;
            }
            api_1.context.with(core_1.suppressTracing(api_1.context.active()), () => {
                var _a;
                logDebugExport(`Exporting span to ${this._exporters.length} exporter(s): %O`, logging_1.spanLogDetails(span));
                this._exporters.forEach((exporter) => exporter.export([span], () => { }));
                (_a = this.batchExporter) === null || _a === void 0 ? void 0 : _a.exportSpan(span);
            });
        }
        catch (err) {
            logDebugExport('error while exporting', err);
        }
    }
}
exports.AspectoProcessor = AspectoProcessor;
/**
 * socket.io reconnect is initiated from setTimeout which does not propagate context
 * thus, user might get spans for reconnect.
 *
 * We cannot place this check in sampler, as it is only initiated after config is received
 */
AspectoProcessor.shouldIgnoreInternalAspectoSpans = (span) => {
    const url = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_URL];
    return (url === null || url === void 0 ? void 0 : url.startsWith(config_1.CONFIG_HOST)) || (url === null || url === void 0 ? void 0 : url.startsWith(config_1.LIVE_FLOW_SOCKET_URL));
};
//# sourceMappingURL=AspectoProcessor.js.map
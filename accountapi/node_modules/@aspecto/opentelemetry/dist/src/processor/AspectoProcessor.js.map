{"version":3,"file":"AspectoProcessor.js","sourceRoot":"","sources":["../../../src/processor/AspectoProcessor.ts"],"names":[],"mappings":"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","sourcesContent":["import { context } from '@opentelemetry/api';\nimport { suppressTracing } from '@opentelemetry/core';\nimport { SpanProcessor, SpanExporter, ReadableSpan } from '@opentelemetry/sdk-trace-base';\nimport createDebug from 'debug';\nimport { PrivacyEngine } from '../privacy-rules/PrivacyEngine';\nimport { ActionResult } from '../privacy-rules/ActionResult';\nimport BatchExporter from './BatchExporter';\nimport { spanLogDetails, SPANS_EXPORT_NS } from '../utils/logging';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\nimport { CONFIG_HOST, LIVE_FLOW_SOCKET_URL } from '../config';\nimport { PrivacyRule } from '../privacy-rules';\nimport { DataCollectionMode } from '../privacy-rules/types/DataCollection';\n\nconst logDebugExport = createDebug(SPANS_EXPORT_NS);\n\nexport class AspectoProcessor implements SpanProcessor {\n    private readonly _exporters: SpanExporter[] = [];\n    private batchExporter: BatchExporter;\n    private privacyEngine: PrivacyEngine;\n    private pendingInitSpans: { sizeBytes: number; span: ReadableSpan }[] = [];\n    private maxPendingInitSpansBytes: number;\n    private pendingInitSpansCurrSize = 0;\n\n    private privacyEnginePromise: Promise<any>;\n    private resolvePrivacyEngine: Function;\n\n    constructor() {\n        const maxPendingInitSpansMb = ((process.env.MAX_PENDING_INIT_SPANS_MB as unknown) as number) || 10;\n        this.maxPendingInitSpansBytes = maxPendingInitSpansMb * 1024 * 1024;\n        this.privacyEnginePromise = new Promise((resolve) => {\n            this.resolvePrivacyEngine = resolve;\n        });\n    }\n\n    public setBatchExporter(exporter: SpanExporter, bufferSize: number, bufferTimeout: number) {\n        if (this.batchExporter) return;\n        this.batchExporter = new BatchExporter(exporter, bufferSize, bufferTimeout);\n    }\n\n    public addExporter(exporter: SpanExporter) {\n        this._exporters.push(exporter);\n    }\n\n    public newDataCollectionRules(rules: PrivacyRule[], mode: DataCollectionMode) {\n        if (this.privacyEngine) {\n            this.privacyEngine.setRules(rules, mode);\n            return;\n        }\n\n        try {\n            this.privacyEngine = new PrivacyEngine();\n            this.privacyEngine.setRules(rules, mode);\n            this.pendingInitSpans.forEach((pendingInitSpan) => this.validateAndExport(pendingInitSpan.span));\n        } catch {\n            this.privacyEngine = null;\n        } finally {\n            this.pendingInitSpans = [];\n            this.pendingInitSpansCurrSize = 0;\n            this.resolvePrivacyEngine();\n        }\n    }\n\n    async forceFlush(): Promise<void> {\n        await this.privacyEnginePromise;\n        if (this.batchExporter)\n            await context.with(suppressTracing(context.active()), () => this.batchExporter.forceFlush());\n    }\n\n    onStart(_span: ReadableSpan): void {}\n\n    onEnd(span: ReadableSpan): void {\n        if (AspectoProcessor.shouldIgnoreInternalAspectoSpans(span)) {\n            logDebugExport('ignoring internal Aspecto span');\n            return;\n        }\n\n        if (!this.privacyEngine) {\n            logDebugExport('Pushing span to pending buffer: %O', spanLogDetails(span));\n            this.pushSpanToPendingInit(span);\n        } else this.validateAndExport(span);\n    }\n\n    async shutdown(): Promise<void> {\n        await this.forceFlush();\n        const shutdownPromises = this._exporters.map((exporter) => exporter.shutdown());\n        if (this.batchExporter) {\n            shutdownPromises.push(this.batchExporter.shutdown());\n        }\n        await Promise.all(shutdownPromises);\n    }\n\n    private pushSpanToPendingInit(span: ReadableSpan): void {\n        const currSpanSize = JSON.stringify(span.attributes).length;\n        this.pendingInitSpansCurrSize += currSpanSize;\n        while (this.pendingInitSpans.length > 0 && this.pendingInitSpansCurrSize >= this.maxPendingInitSpansBytes) {\n            this.pendingInitSpansCurrSize -= this.pendingInitSpans[0].sizeBytes;\n            this.pendingInitSpans.shift();\n        }\n        this.pendingInitSpans.push({ sizeBytes: currSpanSize, span });\n    }\n\n    private validateAndExport(span: ReadableSpan): void {\n        try {\n            const actionResult: ActionResult = this.privacyEngine.executeRules(span);\n            if (actionResult === ActionResult.BlockRequest) {\n                logDebugExport('Span blocked by privacy rules: %O', spanLogDetails(span));\n                return;\n            }\n\n            context.with(suppressTracing(context.active()), () => {\n                logDebugExport(`Exporting span to ${this._exporters.length} exporter(s): %O`, spanLogDetails(span));\n                this._exporters.forEach((exporter) => exporter.export([span], () => {}));\n                this.batchExporter?.exportSpan(span);\n            });\n        } catch (err) {\n            logDebugExport('error while exporting', err);\n        }\n    }\n\n    /**\n     * socket.io reconnect is initiated from setTimeout which does not propagate context\n     * thus, user might get spans for reconnect.\n     *\n     * We cannot place this check in sampler, as it is only initiated after config is received\n     */\n    static shouldIgnoreInternalAspectoSpans = (span: ReadableSpan) => {\n        const url = span.attributes[SemanticAttributes.HTTP_URL] as string;\n        return url?.startsWith(CONFIG_HOST) || url?.startsWith(LIVE_FLOW_SOCKET_URL);\n    };\n}\n"]}
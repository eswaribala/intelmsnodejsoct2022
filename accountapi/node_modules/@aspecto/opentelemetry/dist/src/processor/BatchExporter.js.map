{"version":3,"file":"BatchExporter.js","sourceRoot":"","sources":["../../../src/processor/BatchExporter.ts"],"names":[],"mappings":";;AAGA,MAAqB,aAAa;IAK9B,YACqB,QAAsB,EACtB,UAAkB,EAClB,aAAqB;QAFrB,aAAQ,GAAR,QAAQ,CAAc;QACtB,eAAU,GAAV,UAAU,CAAQ;QAClB,kBAAa,GAAb,aAAa,CAAQ;QAPlC,iBAAY,GAAmB,EAAE,CAAC;QAElC,mBAAc,GAAuB,IAAI,GAAG,EAAE,CAAC;IAMpD,CAAC;IAEJ;;;;;OAKG;IACI,UAAU,CAAC,IAAkB;QAChC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC7B,IAAI,CAAC,eAAe,EAAE,CAAC;QACvB,IAAI,IAAI,CAAC,YAAY,CAAC,MAAM,IAAI,IAAI,CAAC,UAAU,EAAE;YAC7C,IAAI,CAAC,KAAK,EAAE,CAAC;SAChB;IACL,CAAC;IAEM,KAAK,CAAC,UAAU;QACnB,IAAI,CAAC,KAAK,EAAE,CAAC;QACb,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC;IAChD,CAAC;IAEM,KAAK,CAAC,QAAQ;QACjB,MAAM,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC;IACnC,CAAC;IAEO,eAAe;QACnB,IAAI,IAAI,CAAC,OAAO,KAAK,SAAS;YAAE,OAAO;QAEvC,IAAI,CAAC,OAAO,GAAG,UAAU,CAAC,GAAG,EAAE;YAC3B,IAAI,CAAC,KAAK,EAAE,CAAC;QACjB,CAAC,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;QACvB,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;IACzB,CAAC;IAEO,KAAK;QACT,IAAI,CAAC,UAAU,EAAE,CAAC;QAClB,IAAI,IAAI,CAAC,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE;YAChC,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;SAC5B;QACD,MAAM,OAAO,GAAG,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,EAAE;YAC1C,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC;YACtC,IAAI,CAAC,YAAY,GAAG,EAAE,CAAC;YACvB,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC,OAAqB,EAAE,EAAE;gBACxD,mCAAmC;gBACnC,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;gBACpC,OAAO,EAAE,CAAC;YACd,CAAC,CAAC,CAAC;QACP,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QACjC,OAAO,OAAO,CAAC;IACnB,CAAC;IAEO,UAAU;QACd,IAAI,IAAI,CAAC,OAAO,KAAK,SAAS,EAAE;YAC5B,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YAC3B,IAAI,CAAC,OAAO,GAAG,SAAS,CAAC;SAC5B;IACL,CAAC;CACJ;AAnED,gCAmEC","sourcesContent":["import { ExportResult } from '@opentelemetry/core';\nimport { ReadableSpan, SpanExporter } from '@opentelemetry/sdk-trace-base';\n\nexport default class BatchExporter {\n    private batchedSpans: ReadableSpan[] = [];\n    private timerId: NodeJS.Timeout | undefined;\n    private ongoingExports: Set<Promise<void>> = new Set();\n\n    constructor(\n        private readonly exporter: SpanExporter,\n        private readonly bufferSize: number,\n        private readonly bufferTimeout: number\n    ) {}\n\n    /**\n     * Add the span to a batch which will be sent\n     *\n     * @param {ReadableSpan} span\n     * @memberof BatchExporter\n     */\n    public exportSpan(span: ReadableSpan) {\n        this.batchedSpans.push(span);\n        this.maybeStartTimer();\n        if (this.batchedSpans.length >= this.bufferSize) {\n            this.flush();\n        }\n    }\n\n    public async forceFlush(): Promise<void> {\n        this.flush();\n        await Promise.all([...this.ongoingExports]);\n    }\n\n    public async shutdown(): Promise<void> {\n        await this.exporter.shutdown();\n    }\n\n    private maybeStartTimer() {\n        if (this.timerId !== undefined) return;\n\n        this.timerId = setTimeout(() => {\n            this.flush();\n        }, this.bufferTimeout);\n        this.timerId.unref();\n    }\n\n    private flush(): Promise<void> {\n        this.clearTimer();\n        if (this.batchedSpans.length === 0) {\n            return Promise.resolve();\n        }\n        const promise = new Promise<void>((resolve) => {\n            const batchToSend = this.batchedSpans;\n            this.batchedSpans = [];\n            this.exporter.export(batchToSend, (_result: ExportResult) => {\n                // consider to implement retry here\n                this.ongoingExports.delete(promise);\n                resolve();\n            });\n        });\n        this.ongoingExports.add(promise);\n        return promise;\n    }\n\n    private clearTimer() {\n        if (this.timerId !== undefined) {\n            clearTimeout(this.timerId);\n            this.timerId = undefined;\n        }\n    }\n}\n"]}
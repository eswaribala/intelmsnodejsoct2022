"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.instrumentHttpTrigger = void 0;
const api_1 = require("@opentelemetry/api");
const opentelemetry_base_1 = require("@aspecto/opentelemetry-base");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const clean_stack_trace_1 = require("../clean-stack-trace");
const version_1 = require("../../version");
const http_headers_1 = require("../../plugins-customizations/http-headers");
const parseBody = (body) => {
    if (typeof body !== 'object')
        return body;
    try {
        return JSON.stringify(body);
    }
    catch (_a) {
        return undefined;
    }
};
exports.instrumentHttpTrigger = (handler, waitForSpansExport) => async (req, res) => {
    var _a, _b, _c, _d, _e;
    const otelContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, (_a = req.headers) !== null && _a !== void 0 ? _a : {});
    const tracer = api_1.trace.getTracer('gcf', version_1.VERSION);
    const funcName = (_b = process.env.K_SERVICE) !== null && _b !== void 0 ? _b : 'unknown-name';
    const host = (_d = (_c = req.get('host')) !== null && _c !== void 0 ? _c : req.hostname) !== null && _d !== void 0 ? _d : 'localhost';
    const newSpan = tracer.startSpan(`GCF ${funcName} - ${process.env.FUNCTION_TARGET}`, {
        attributes: Object.assign({ [semantic_conventions_1.SemanticResourceAttributes.CLOUD_PROVIDER]: 'gcp', [semantic_conventions_1.SemanticResourceAttributes.FAAS_NAME]: funcName, [semantic_conventions_1.SemanticResourceAttributes.FAAS_ID]: `${host}/${funcName}`, [semantic_conventions_1.SemanticAttributes.FAAS_TRIGGER]: 'http', [semantic_conventions_1.SemanticAttributes.FAAS_EXECUTION]: req.get('function-execution-id'), [semantic_conventions_1.SemanticResourceAttributes.FAAS_VERSION]: process.env.K_REVISION, [semantic_conventions_1.SemanticAttributes.HTTP_ROUTE]: req.route, [semantic_conventions_1.SemanticAttributes.HTTP_SCHEME]: 'https', [semantic_conventions_1.SemanticAttributes.HTTP_FLAVOR]: req.httpVersion, [semantic_conventions_1.SemanticAttributes.HTTP_USER_AGENT]: req.get('user-agent'), [semantic_conventions_1.SemanticAttributes.HTTP_METHOD]: (_e = req.method) === null || _e === void 0 ? void 0 : _e.toUpperCase(), [semantic_conventions_1.SemanticAttributes.HTTP_TARGET]: `/${funcName}${req.originalUrl}`, [semantic_conventions_1.SemanticAttributes.HTTP_HOST]: host, [semantic_conventions_1.SemanticAttributes.NET_PEER_IP]: req.ip, [opentelemetry_base_1.AspectoAttributeNames.HTTP_PATH]: req.path, [opentelemetry_base_1.AspectoAttributeNames.HTTP_REQUEST_BODY]: parseBody(req.body) }, http_headers_1.httpHeadersToSpanAttributes('request', req.headers)),
        kind: api_1.SpanKind.SERVER,
    }, otelContext);
    const oldSend = res.send;
    let ended = false;
    res.send = (body) => {
        if (!ended) {
            newSpan.setAttributes(Object.assign({ [semantic_conventions_1.SemanticAttributes.HTTP_STATUS_CODE]: res.statusCode, [opentelemetry_base_1.AspectoAttributeNames.HTTP_RESPONSE_BODY]: parseBody(body) }, http_headers_1.httpHeadersToSpanAttributes('response', res.getHeaders())));
            newSpan.end();
            ended = true;
        }
        return oldSend.call(res, body);
    };
    try {
        await api_1.context.with(api_1.trace.setSpan(api_1.context.active(), newSpan), () => handler(req, res));
    }
    catch (err) {
        clean_stack_trace_1.cleanStackTrace(err);
        if (!ended) {
            newSpan.setStatus({
                code: api_1.SpanStatusCode.ERROR,
                message: err.message,
            });
            newSpan.end();
            ended = true;
        }
        throw err;
    }
    finally {
        await waitForSpansExport();
    }
};
//# sourceMappingURL=http-trigger.js.map
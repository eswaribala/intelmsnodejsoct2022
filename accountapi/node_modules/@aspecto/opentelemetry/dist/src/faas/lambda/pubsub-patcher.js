"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.patchSnsRecords = exports.patchSqsRecords = void 0;
const api_1 = require("@opentelemetry/api");
const propagation_utils_1 = require("@opentelemetry/propagation-utils");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const opentelemetry_base_1 = require("@aspecto/opentelemetry-base");
class SnsContextGetter {
    keys(carrier) {
        return Object.keys(carrier);
    }
    get(carrier, key) {
        var _a;
        return (_a = carrier === null || carrier === void 0 ? void 0 : carrier[key]) === null || _a === void 0 ? void 0 : _a.Value;
    }
}
const snsContextGetter = new SnsContextGetter();
class SqsContextGetter {
    keys(carrier) {
        return Object.keys(carrier);
    }
    get(carrier, key) {
        var _a;
        return (_a = carrier === null || carrier === void 0 ? void 0 : carrier[key]) === null || _a === void 0 ? void 0 : _a.stringValue;
    }
}
const sqsContextGetter = new SqsContextGetter();
exports.patchSqsRecords = ({ messages, faasRootContext, queueUrl, queueName }) => {
    if (!(messages === null || messages === void 0 ? void 0 : messages.length))
        return;
    const tracer = api_1.trace.getTracer('lambda-sqs');
    propagation_utils_1.pubsubPropagation.patchArrayForProcessSpans(messages, tracer);
    const messageToSpanDetails = (message) => ({
        attributes: {
            [semantic_conventions_1.SemanticAttributes.MESSAGING_SYSTEM]: 'aws.sqs',
            [semantic_conventions_1.SemanticAttributes.MESSAGING_DESTINATION]: queueName,
            [semantic_conventions_1.SemanticAttributes.MESSAGING_DESTINATION_KIND]: semantic_conventions_1.MessagingDestinationKindValues.QUEUE,
            [semantic_conventions_1.SemanticAttributes.MESSAGING_MESSAGE_ID]: message.messageId,
            [semantic_conventions_1.SemanticAttributes.MESSAGING_URL]: queueUrl,
            [opentelemetry_base_1.MessagingExtendedAttribute.MESSAGING_PAYLOAD]: typeof message.body === 'string' ? message.body : JSON.stringify(message.body),
        },
        name: queueName,
        parentContext: api_1.propagation.extract(api_1.ROOT_CONTEXT, message.messageAttributes, sqsContextGetter),
    });
    propagation_utils_1.pubsubPropagation.patchMessagesArrayToStartProcessSpans({
        messages,
        tracer,
        parentContext: faasRootContext,
        messageToSpanDetails,
    });
};
exports.patchSnsRecords = ({ messages, faasRootContext, topicName }) => {
    if (!(messages === null || messages === void 0 ? void 0 : messages.length))
        return;
    const tracer = api_1.trace.getTracer('lambda-sns');
    propagation_utils_1.pubsubPropagation.patchArrayForProcessSpans(messages, tracer);
    const messageToSpanDetails = (message) => ({
        attributes: {
            [semantic_conventions_1.SemanticAttributes.MESSAGING_SYSTEM]: 'aws.sns',
            [semantic_conventions_1.SemanticAttributes.MESSAGING_DESTINATION]: topicName,
            [semantic_conventions_1.SemanticAttributes.MESSAGING_DESTINATION_KIND]: semantic_conventions_1.MessagingDestinationKindValues.TOPIC,
            [semantic_conventions_1.SemanticAttributes.MESSAGING_MESSAGE_ID]: message.Sns.MessageId,
            [opentelemetry_base_1.MessagingExtendedAttribute.MESSAGING_PAYLOAD]: typeof message.Sns.Message === 'string' ? message.Sns.Message : JSON.stringify(message.Sns.Message),
        },
        name: topicName,
        parentContext: api_1.propagation.extract(api_1.ROOT_CONTEXT, message.Sns.MessageAttributes, snsContextGetter),
    });
    propagation_utils_1.pubsubPropagation.patchMessagesArrayToStartProcessSpans({
        messages,
        tracer,
        parentContext: faasRootContext,
        messageToSpanDetails,
    });
};
//# sourceMappingURL=pubsub-patcher.js.map
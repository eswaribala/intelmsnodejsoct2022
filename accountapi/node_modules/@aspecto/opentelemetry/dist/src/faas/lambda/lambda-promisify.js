"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.promisifyHandler = exports.ResponseType = void 0;
var ResponseType;
(function (ResponseType) {
    ResponseType[ResponseType["AsyncResolved"] = 0] = "AsyncResolved";
    ResponseType[ResponseType["AsyncError"] = 1] = "AsyncError";
    ResponseType[ResponseType["Callback"] = 2] = "Callback";
    ResponseType[ResponseType["CallbackError"] = 3] = "CallbackError";
})(ResponseType = exports.ResponseType || (exports.ResponseType = {}));
const isPromise = (obj) => typeof (obj === null || obj === void 0 ? void 0 : obj.then) === 'function';
const callbackResolver = (resolve) => (err, data) => resolve({ err, data, type: ResponseType.Callback });
// We need to support both callback and async-await usages
exports.promisifyHandler = (handler, event, context) => new Promise((resolve) => {
    try {
        const result = handler(event, context, callbackResolver(resolve));
        if (isPromise(result)) {
            result
                .then((data) => resolve({ err: null, data, type: ResponseType.AsyncResolved }))
                .catch((err) => resolve({ err, data: null, type: ResponseType.AsyncError }));
        }
    }
    catch (err) {
        resolve({ err, data: null, type: ResponseType.CallbackError });
    }
});
//# sourceMappingURL=lambda-promisify.js.map
{"version":3,"file":"lambda-promisify.js","sourceRoot":"","sources":["../../../../src/faas/lambda/lambda-promisify.ts"],"names":[],"mappings":";;;AAAA,IAAY,YAKX;AALD,WAAY,YAAY;IACpB,iEAAa,CAAA;IACb,2DAAU,CAAA;IACV,uDAAQ,CAAA;IACR,iEAAa,CAAA;AACjB,CAAC,EALW,YAAY,GAAZ,oBAAY,KAAZ,oBAAY,QAKvB;AAQD,MAAM,SAAS,GAAG,CAAC,GAAQ,EAAE,EAAE,CAAC,QAAO,GAAG,aAAH,GAAG,uBAAH,GAAG,CAAE,IAAI,CAAA,KAAK,UAAU,CAAC;AAEhE,MAAM,gBAAgB,GAAG,CAAC,OAAiB,EAAE,EAAE,CAAC,CAAC,GAAU,EAAE,IAAS,EAAE,EAAE,CACtE,OAAO,CAAC,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,YAAY,CAAC,QAAQ,EAAE,CAAC,CAAC;AAExD,0DAA0D;AAC7C,QAAA,gBAAgB,GAAG,CAAC,OAAiB,EAAE,KAAU,EAAE,OAAY,EAAE,EAAE,CAC5E,IAAI,OAAO,CAAoB,CAAC,OAAO,EAAE,EAAE;IACvC,IAAI;QACA,MAAM,MAAM,GAAG,OAAO,CAAC,KAAK,EAAE,OAAO,EAAE,gBAAgB,CAAC,OAAO,CAAC,CAAC,CAAC;QAClE,IAAI,SAAS,CAAC,MAAM,CAAC,EAAE;YACnB,MAAM;iBACD,IAAI,CAAC,CAAC,IAAS,EAAE,EAAE,CAAC,OAAO,CAAC,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,YAAY,CAAC,aAAa,EAAE,CAAC,CAAC;iBACnF,KAAK,CAAC,CAAC,GAAU,EAAE,EAAE,CAAC,OAAO,CAAC,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,YAAY,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC;SAC3F;KACJ;IAAC,OAAO,GAAG,EAAE;QACV,OAAO,CAAC,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,YAAY,CAAC,aAAa,EAAE,CAAC,CAAC;KAClE;AACL,CAAC,CAAC,CAAC","sourcesContent":["export enum ResponseType {\n    AsyncResolved,\n    AsyncError,\n    Callback,\n    CallbackError,\n}\n\ninterface PromisifyResponse {\n    err?: Error;\n    data?: any;\n    type: ResponseType;\n}\n\nconst isPromise = (obj: any) => typeof obj?.then === 'function';\n\nconst callbackResolver = (resolve: Function) => (err: Error, data: any) =>\n    resolve({ err, data, type: ResponseType.Callback });\n\n// We need to support both callback and async-await usages\nexport const promisifyHandler = (handler: Function, event: any, context: any) =>\n    new Promise<PromisifyResponse>((resolve) => {\n        try {\n            const result = handler(event, context, callbackResolver(resolve));\n            if (isPromise(result)) {\n                result\n                    .then((data: any) => resolve({ err: null, data, type: ResponseType.AsyncResolved }))\n                    .catch((err: Error) => resolve({ err, data: null, type: ResponseType.AsyncError }));\n            }\n        } catch (err) {\n            resolve({ err, data: null, type: ResponseType.CallbackError });\n        }\n    });\n"]}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessagingProcessSampler = void 0;
const api_1 = require("@opentelemetry/api");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const sampling_rules_1 = require("@aspecto/sampling-rules");
const opentelemetry_base_1 = require("@aspecto/opentelemetry-base");
class MessagingProcessSampler {
    constructor(rulesSampler, serviceSampler) {
        this.rulesSampler = rulesSampler;
        this.serviceSampler = serviceSampler;
    }
    shouldSample(_context, _traceId, _spanName, _spanKind, attributes, links) {
        const messagingOperation = attributes[semantic_conventions_1.SemanticAttributes.MESSAGING_OPERATION];
        if (messagingOperation === semantic_conventions_1.MessagingOperationValues.PROCESS) {
            try {
                const sampleResult = this.shouldSampleProcessing(attributes, links);
                if (sampleResult)
                    return sampleResult;
            }
            catch (e) {
                api_1.diag.warn('got exception when applying sampling decision for process span. falling back to global sampler', e);
            }
        }
        return this.serviceSampler.shouldSample.apply(this.serviceSampler, arguments);
    }
    shouldSampleProcessing(attributes, links) {
        // Here we differentiate between 2 options:
        //
        // 1. Sample process spans based on the *remote sampling decision* received from the publisher via otel link.
        // This is the preferred option as it provides E2E visibility:
        // if the sender is sampled, we have the trace that consumed it,
        // and if we consumed a message we have the trace that published it.
        //
        // 2. Process spans apply the decision from the general sampling configuration of the otel installation.
        // The downside is that we lose the E2E visibility.
        // The benefit is that sampling is easier to understand and argue about, and it works regardless
        // of the publisher being instrumented and context being properly propagated.
        var _a;
        // If we don't have link, then even in option (1) we cannot implement sampling based
        // on publisher decision, thus we fallback to general service decision (2)
        if (links.length === 0)
            return;
        // The following code should differentiate between option (1) and (2).
        // The decision is taken on the rule that matched the entry span of the trace.
        // Best way to propagate the decision is via the otel context, but due to technical problem:
        // https://github.com/open-telemetry/opentelemetry-js-api/pull/123
        // we currently apply a hack to re-evaluate the decision.
        // in the future we should change to use context.attach and read the decision here from context.active.getValue(...)
        const messagingDestination = attributes[semantic_conventions_1.SemanticAttributes.MESSAGING_DESTINATION];
        const receiveAttributes = {
            [semantic_conventions_1.SemanticAttributes.MESSAGING_OPERATION]: semantic_conventions_1.MessagingOperationValues.RECEIVE,
            [semantic_conventions_1.SemanticAttributes.MESSAGING_DESTINATION]: messagingDestination,
        };
        const receiveMatchedRule = this.rulesSampler.getMatchingRule(`${messagingDestination} ${semantic_conventions_1.MessagingOperationValues.RECEIVE}`, receiveAttributes);
        const inheritContext = (_a = receiveMatchedRule === null || receiveMatchedRule === void 0 ? void 0 : receiveMatchedRule.context) === null || _a === void 0 ? void 0 : _a[sampling_rules_1.RulesContextKeys.MESSAGING_SAMPLING_INHERIT_FROM_PUBLISHER];
        if (!inheritContext)
            return;
        const publisherContext = links[0].context;
        const sampled = publisherContext.traceFlags & api_1.TraceFlags.SAMPLED;
        return {
            decision: sampled ? api_1.SamplingDecision.RECORD_AND_SAMPLED : api_1.SamplingDecision.NOT_RECORD,
            attributes: {
                [opentelemetry_base_1.AspectoAttributeNames.ASPECTO_SAMPLING_MESSAGING_REMOTE_RULE_ID]: receiveMatchedRule._id,
            },
        };
    }
    toString() {
        return 'MessagingProcessSampler';
    }
}
exports.MessagingProcessSampler = MessagingProcessSampler;
//# sourceMappingURL=MessageProcessSampler.js.map
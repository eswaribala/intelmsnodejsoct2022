"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RulesSampler = void 0;
const opentelemetry_base_1 = require("@aspecto/opentelemetry-base");
const sampling_rules_1 = require("@aspecto/sampling-rules");
const core_1 = require("@opentelemetry/core");
const stringifyDefined = (val) => {
    if (val === null || val === undefined || typeof val === 'string')
        return val;
    return String(val);
};
const allConditionsSatisfied = (conditions, spanName, attributes) => conditions.every((con) => {
    switch (con.from) {
        case 'attribute':
            return sampling_rules_1.meetsOperator(con.comparison, con.value, stringifyDefined(attributes[con.key]));
        case 'operation':
            return sampling_rules_1.meetsOperator(con.comparison, con.value, spanName);
        // Other "from" are not implemented for now.
        default:
            return false;
    }
});
class RulesSampler {
    constructor(ratio, packageName, env, requireConfigForTraces) {
        this.ratio = ratio;
        this.packageName = packageName;
        this.env = env;
        this.localSampler = requireConfigForTraces ? new core_1.AlwaysOffSampler() : new core_1.TraceIdRatioBasedSampler(this.ratio);
    }
    setRules(rules) {
        if (!this.gotRules()) {
            this.onFirstRulesConfig();
        }
        this.rules = sampling_rules_1.filterRulesByPackageNameAndEnv(rules, this.packageName, this.env).map((rule) => (Object.assign(Object.assign({}, rule), { sampler: new core_1.TraceIdRatioBasedSampler(rule.samplingRate) })));
    }
    getMatchingRule(spanName, attributes) {
        var _a;
        return (_a = this.rules) === null || _a === void 0 ? void 0 : _a.find((rule) => allConditionsSatisfied(rule.conditions, spanName, attributes));
    }
    onFirstRulesConfig() {
        this.localSampler = new core_1.TraceIdRatioBasedSampler(this.ratio);
    }
    gotRules() {
        return this.rules !== undefined;
    }
    shouldSample(context, traceId, spanName, spanKind, attributes, links) {
        const rule = this.getMatchingRule(spanName, attributes);
        if (rule) {
            const decision = rule.sampler.shouldSample(context, traceId).decision;
            const attributes = {
                [opentelemetry_base_1.AspectoAttributeNames.ASPECTO_SAMPLING_RULE_ID]: rule._id,
            };
            return { decision, attributes };
        }
        else {
            const { decision } = this.localSampler.shouldSample(context, traceId, spanName, spanKind, attributes, links);
            const samplingAttributes = {
                [opentelemetry_base_1.AspectoAttributeNames.ASPECTO_SAMPLING_LOCAL_SAMPLER_NAME]: this.localSampler.toString(),
            };
            if (!this.gotRules()) {
                samplingAttributes[opentelemetry_base_1.AspectoAttributeNames.ASPECTO_SAMPLING_UNINITIALIZED] = true;
            }
            return { decision, attributes: samplingAttributes };
        }
    }
    toString() {
        var _a, _b;
        return `RulesSampler{${(_b = (_a = this.rules) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 'uninitialized'} rules}`;
    }
}
exports.RulesSampler = RulesSampler;
//# sourceMappingURL=RulesSampler.js.map
{"version":3,"file":"actions.js","sourceRoot":"","sources":["../../../../src/privacy-rules/block/actions.ts"],"names":[],"mappings":"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","sourcesContent":["import { ReadableSpan } from '@opentelemetry/sdk-trace-base';\nimport { SpanAttributes } from '@opentelemetry/api';\nimport { AspectoAttributeNames } from '@aspecto/opentelemetry-base';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\nimport { RuleAction, ActionType, FieldAction, FieldFilter } from '../types/PrivacyRule';\nimport { scramble } from './scrambler';\nimport { ActionResult } from '../ActionResult';\nimport { compareStr } from '../utils';\nimport url from 'url';\nimport { normalizedHeaderToAttribute, normalizeHeader } from '../../plugins-customizations/http-headers';\n\nconst FIELD_BLOCKED: string = '__aspecto_field_blocked__';\n\nconst checkFieldFilter = (filter: FieldFilter, key: string, value: string) => {\n    const { filterType, filterValue } = filter;\n    switch (filterType) {\n        case 'by-key':\n            return compareStr(key, filterValue);\n        case 'by-value':\n            return compareStr(value, filterValue);\n        default:\n            throw new Error(`Unknown filter: ${JSON.stringify(filter)}`);\n    }\n};\n\nconst executeFilteredAction = (\n    actionType: ActionType,\n    fieldFilter: FieldFilter,\n    obj: any,\n    stopRecursion: boolean = false\n): boolean => {\n    if (!obj) return false;\n\n    let filterExecuted = false;\n\n    if (obj instanceof Array && !stopRecursion) {\n        for (let element of obj) {\n            const currFilterExecuted: boolean = executeFilteredAction(actionType, fieldFilter, element, true);\n            filterExecuted = filterExecuted || currFilterExecuted;\n        }\n        return filterExecuted;\n    }\n\n    for (let key of Object.keys(obj)) {\n        const value = obj[key];\n        if (checkFieldFilter(fieldFilter, key, value)) {\n            switch (actionType) {\n                case 'scramble-field':\n                    obj[key] = scramble(value);\n                    filterExecuted = true;\n                    break;\n                case 'block-field':\n                    obj[key] = FIELD_BLOCKED;\n                    filterExecuted = true;\n                    break;\n                default:\n                    throw new Error(`Unknown action type: ${JSON.stringify(actionType)}`);\n            }\n        }\n    }\n\n    return filterExecuted;\n};\n\nconst scrambleHttpHeader = (attributeName: string, spanAttributes: SpanAttributes) => {\n    const headerValues = spanAttributes[attributeName] as string[];\n    if (!Array.isArray(headerValues)) {\n        return;\n    }\n    spanAttributes[attributeName] = headerValues.map((v) => scramble(v));\n};\n\nconst executeFilterActionOnHeaders = (\n    actionType: ActionType,\n    fieldFilter: FieldFilter,\n    spanAttributes: SpanAttributes\n) => {\n    const { filterValue, filterType } = fieldFilter;\n    switch (filterType) {\n        case 'by-key':\n            const normalizedHeader = normalizeHeader(filterValue);\n            const attributeNames = [\n                normalizedHeaderToAttribute('request', normalizedHeader),\n                normalizedHeaderToAttribute('response', normalizedHeader),\n            ];\n            switch (actionType) {\n                case 'block-field':\n                    attributeNames.forEach((attr) => (spanAttributes[attr] = FIELD_BLOCKED));\n                    break;\n                case 'scramble-field':\n                    attributeNames.forEach((attr) => scrambleHttpHeader(attr, spanAttributes));\n                    break;\n            }\n            break;\n        case 'by-value':\n            throw new Error('trying to apply block filter rule on http header by value. this is not supported');\n        default:\n            throw new Error(`Unknown filter: ${JSON.stringify(filterType)}`);\n    }\n};\n\nconst executeFilterActionOnQuery = (\n    actionType: ActionType,\n    fieldFilter: FieldFilter,\n    spanAttributes: SpanAttributes,\n    attributeKey: string\n) => {\n    const urlStr: string = spanAttributes[attributeKey] as string;\n    if (!urlStr) return;\n\n    const urlObj = url.parse(urlStr, true);\n    if (!urlObj.search) return;\n\n    const filterExecuted: boolean = executeFilteredAction(actionType, fieldFilter, urlObj.query);\n    if (filterExecuted) {\n        // remove search string so object will be built with modified query object\n        delete urlObj.search;\n        spanAttributes[attributeKey] = url.format(urlObj);\n    }\n};\n\nconst executeFilterActionOnAttribute = (\n    actionType: ActionType,\n    fieldFilter: FieldFilter,\n    spanAttributes: SpanAttributes,\n    attributeKey: string,\n    parsedAttributesCache: Record<string, any>\n): boolean => {\n    const attributeValue = spanAttributes[attributeKey];\n    if (!attributeValue || typeof attributeValue !== 'string') return false;\n\n    let attributeAsJsonObj: any;\n    try {\n        const previouslyParsed = parsedAttributesCache[attributeKey];\n        if (previouslyParsed) {\n            attributeAsJsonObj = previouslyParsed;\n        } else {\n            attributeAsJsonObj = JSON.parse(attributeValue);\n            parsedAttributesCache[attributeKey] = attributeAsJsonObj;\n        }\n    } catch {\n        return;\n    }\n\n    return executeFilteredAction(actionType, fieldFilter, attributeAsJsonObj);\n};\n\nconst executeFieldAction = (action: FieldAction, msg: ReadableSpan, parsedAttributesCache: Record<string, any>) => {\n    const {\n        actionType,\n        actionData: { fieldTypes, filter },\n    } = action;\n    fieldTypes.forEach((fieldType) => {\n        switch (fieldType) {\n            case 'body-json':\n                executeFilterActionOnAttribute(\n                    actionType,\n                    filter,\n                    msg.attributes,\n                    AspectoAttributeNames.HTTP_RESPONSE_BODY,\n                    parsedAttributesCache\n                );\n                executeFilterActionOnAttribute(\n                    actionType,\n                    filter,\n                    msg.attributes,\n                    AspectoAttributeNames.HTTP_REQUEST_BODY,\n                    parsedAttributesCache\n                );\n                return;\n\n            case 'header':\n                executeFilterActionOnHeaders(actionType, filter, msg.attributes);\n                return;\n\n            case 'query-param':\n                executeFilterActionOnQuery(actionType, filter, msg.attributes, SemanticAttributes.HTTP_TARGET);\n                executeFilterActionOnQuery(actionType, filter, msg.attributes, SemanticAttributes.HTTP_URL);\n                return;\n\n            default:\n                throw new Error(`Unknown field type: ${JSON.stringify(fieldType)}`);\n        }\n    });\n    return false;\n};\n\nconst executeAction = (\n    action: RuleAction,\n    msg: ReadableSpan,\n    parsedAttributesCache: Record<string, any>\n): ActionResult => {\n    const { actionType } = action;\n    switch (actionType) {\n        case 'scramble-field':\n        case 'block-field':\n            executeFieldAction(action as FieldAction, msg, parsedAttributesCache);\n            break;\n        case 'block-request':\n            return ActionResult.BlockRequest;\n        default:\n            throw new Error(`Unknown action: ${JSON.stringify(action)}`);\n    }\n};\n\nexport const executeActions = (\n    actions: RuleAction[],\n    msg: ReadableSpan,\n    parsedAttributesCache: Record<string, any>\n): ActionResult => {\n    for (let action of actions) {\n        const result = executeAction(action, msg, parsedAttributesCache);\n        if (result === ActionResult.BlockRequest) {\n            // one blocking action is enough, no need to execute other actions\n            return result;\n        }\n    }\n    return ActionResult.None;\n};\n"]}
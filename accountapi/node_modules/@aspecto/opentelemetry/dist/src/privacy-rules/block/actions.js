"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeActions = void 0;
const opentelemetry_base_1 = require("@aspecto/opentelemetry-base");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const scrambler_1 = require("./scrambler");
const ActionResult_1 = require("../ActionResult");
const utils_1 = require("../utils");
const url_1 = __importDefault(require("url"));
const http_headers_1 = require("../../plugins-customizations/http-headers");
const FIELD_BLOCKED = '__aspecto_field_blocked__';
const checkFieldFilter = (filter, key, value) => {
    const { filterType, filterValue } = filter;
    switch (filterType) {
        case 'by-key':
            return utils_1.compareStr(key, filterValue);
        case 'by-value':
            return utils_1.compareStr(value, filterValue);
        default:
            throw new Error(`Unknown filter: ${JSON.stringify(filter)}`);
    }
};
const executeFilteredAction = (actionType, fieldFilter, obj, stopRecursion = false) => {
    if (!obj)
        return false;
    let filterExecuted = false;
    if (obj instanceof Array && !stopRecursion) {
        for (let element of obj) {
            const currFilterExecuted = executeFilteredAction(actionType, fieldFilter, element, true);
            filterExecuted = filterExecuted || currFilterExecuted;
        }
        return filterExecuted;
    }
    for (let key of Object.keys(obj)) {
        const value = obj[key];
        if (checkFieldFilter(fieldFilter, key, value)) {
            switch (actionType) {
                case 'scramble-field':
                    obj[key] = scrambler_1.scramble(value);
                    filterExecuted = true;
                    break;
                case 'block-field':
                    obj[key] = FIELD_BLOCKED;
                    filterExecuted = true;
                    break;
                default:
                    throw new Error(`Unknown action type: ${JSON.stringify(actionType)}`);
            }
        }
    }
    return filterExecuted;
};
const scrambleHttpHeader = (attributeName, spanAttributes) => {
    const headerValues = spanAttributes[attributeName];
    if (!Array.isArray(headerValues)) {
        return;
    }
    spanAttributes[attributeName] = headerValues.map((v) => scrambler_1.scramble(v));
};
const executeFilterActionOnHeaders = (actionType, fieldFilter, spanAttributes) => {
    const { filterValue, filterType } = fieldFilter;
    switch (filterType) {
        case 'by-key':
            const normalizedHeader = http_headers_1.normalizeHeader(filterValue);
            const attributeNames = [
                http_headers_1.normalizedHeaderToAttribute('request', normalizedHeader),
                http_headers_1.normalizedHeaderToAttribute('response', normalizedHeader),
            ];
            switch (actionType) {
                case 'block-field':
                    attributeNames.forEach((attr) => (spanAttributes[attr] = FIELD_BLOCKED));
                    break;
                case 'scramble-field':
                    attributeNames.forEach((attr) => scrambleHttpHeader(attr, spanAttributes));
                    break;
            }
            break;
        case 'by-value':
            throw new Error('trying to apply block filter rule on http header by value. this is not supported');
        default:
            throw new Error(`Unknown filter: ${JSON.stringify(filterType)}`);
    }
};
const executeFilterActionOnQuery = (actionType, fieldFilter, spanAttributes, attributeKey) => {
    const urlStr = spanAttributes[attributeKey];
    if (!urlStr)
        return;
    const urlObj = url_1.default.parse(urlStr, true);
    if (!urlObj.search)
        return;
    const filterExecuted = executeFilteredAction(actionType, fieldFilter, urlObj.query);
    if (filterExecuted) {
        // remove search string so object will be built with modified query object
        delete urlObj.search;
        spanAttributes[attributeKey] = url_1.default.format(urlObj);
    }
};
const executeFilterActionOnAttribute = (actionType, fieldFilter, spanAttributes, attributeKey, parsedAttributesCache) => {
    const attributeValue = spanAttributes[attributeKey];
    if (!attributeValue || typeof attributeValue !== 'string')
        return false;
    let attributeAsJsonObj;
    try {
        const previouslyParsed = parsedAttributesCache[attributeKey];
        if (previouslyParsed) {
            attributeAsJsonObj = previouslyParsed;
        }
        else {
            attributeAsJsonObj = JSON.parse(attributeValue);
            parsedAttributesCache[attributeKey] = attributeAsJsonObj;
        }
    }
    catch (_a) {
        return;
    }
    return executeFilteredAction(actionType, fieldFilter, attributeAsJsonObj);
};
const executeFieldAction = (action, msg, parsedAttributesCache) => {
    const { actionType, actionData: { fieldTypes, filter }, } = action;
    fieldTypes.forEach((fieldType) => {
        switch (fieldType) {
            case 'body-json':
                executeFilterActionOnAttribute(actionType, filter, msg.attributes, opentelemetry_base_1.AspectoAttributeNames.HTTP_RESPONSE_BODY, parsedAttributesCache);
                executeFilterActionOnAttribute(actionType, filter, msg.attributes, opentelemetry_base_1.AspectoAttributeNames.HTTP_REQUEST_BODY, parsedAttributesCache);
                return;
            case 'header':
                executeFilterActionOnHeaders(actionType, filter, msg.attributes);
                return;
            case 'query-param':
                executeFilterActionOnQuery(actionType, filter, msg.attributes, semantic_conventions_1.SemanticAttributes.HTTP_TARGET);
                executeFilterActionOnQuery(actionType, filter, msg.attributes, semantic_conventions_1.SemanticAttributes.HTTP_URL);
                return;
            default:
                throw new Error(`Unknown field type: ${JSON.stringify(fieldType)}`);
        }
    });
    return false;
};
const executeAction = (action, msg, parsedAttributesCache) => {
    const { actionType } = action;
    switch (actionType) {
        case 'scramble-field':
        case 'block-field':
            executeFieldAction(action, msg, parsedAttributesCache);
            break;
        case 'block-request':
            return ActionResult_1.ActionResult.BlockRequest;
        default:
            throw new Error(`Unknown action: ${JSON.stringify(action)}`);
    }
};
exports.executeActions = (actions, msg, parsedAttributesCache) => {
    for (let action of actions) {
        const result = executeAction(action, msg, parsedAttributesCache);
        if (result === ActionResult_1.ActionResult.BlockRequest) {
            // one blocking action is enough, no need to execute other actions
            return result;
        }
    }
    return ActionResult_1.ActionResult.None;
};
//# sourceMappingURL=actions.js.map
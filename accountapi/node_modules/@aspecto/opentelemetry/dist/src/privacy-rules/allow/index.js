"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AllowList = void 0;
const conditions_1 = require("./conditions");
const ActionResult_1 = require("../ActionResult");
const DataCollection_1 = require("../types/DataCollection");
const lodash_1 = require("lodash");
const http_headers_1 = require("../../plugins-customizations/http-headers");
const pick = (obj, props) => {
    return props.reduce((result, key) => {
        if (lodash_1.has(obj, key)) {
            lodash_1.set(result, key, lodash_1.get(obj, key));
        }
        return result;
    }, {});
};
const isAttributeHttpHeader = (attrName) => {
    return attrName.startsWith('http.request.header.') || attrName.startsWith('http.response.header.');
};
const deleteHttpHeaderAttributes = (span, fieldsToCollect) => {
    const normalizedToHeaderNames = Object.keys(fieldsToCollect).map(http_headers_1.normalizeHeader);
    Object.keys(span.attributes).forEach((attrName) => {
        if (isAttributeHttpHeader(attrName) &&
            normalizedToHeaderNames.find((f) => attrName.endsWith(f)) === undefined) {
            delete span.attributes[attrName];
        }
    });
};
class AllowList {
    removeAttributes(obj, fieldsToCollect) {
        if (obj instanceof Array) {
            return obj.map((e) => this.removeAttributes(e, fieldsToCollect));
        }
        return pick(obj, Object.keys(fieldsToCollect));
    }
    updateSpan(span, fieldsToCollect) {
        const payloadKeys = Object.values(DataCollection_1.payloadAttributeName);
        for (const payloadKey of payloadKeys) {
            if (span.attributes[payloadKey] === undefined) {
                continue;
            }
            try {
                const originalPayload = JSON.parse(span.attributes[payloadKey].toString());
                const payload = this.removeAttributes(originalPayload, fieldsToCollect);
                span.attributes[payloadKey] = JSON.stringify(payload);
            }
            catch (_a) { }
        }
        deleteHttpHeaderAttributes(span, fieldsToCollect);
    }
    executeAction(actions, _span, properties) {
        for (const action of actions) {
            properties[action.actionData.filter.filterValue] = true;
        }
        return ActionResult_1.ActionResult.None;
    }
    checkCondition(condition, span) {
        return conditions_1.checkCondition(condition, span);
    }
}
exports.AllowList = AllowList;
//# sourceMappingURL=index.js.map
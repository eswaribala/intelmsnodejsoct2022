"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const api_1 = require("@opentelemetry/api");
const core_1 = require("@opentelemetry/core");
const exporter_trace_otlp_proto_1 = require("@opentelemetry/exporter-trace-otlp-proto");
const exporter_trace_otlp_http_1 = require("@opentelemetry/exporter-trace-otlp-http");
const sdk_trace_node_1 = require("@opentelemetry/sdk-trace-node");
const exporter_zipkin_1 = require("@opentelemetry/exporter-zipkin");
const debug_1 = __importDefault(require("debug"));
const opentelemetry_diag_1 = require("@aspecto/opentelemetry-diag");
const config_1 = require("./config");
const AspectoProcessor_1 = require("./processor/AspectoProcessor");
const print_live_message_1 = require("./logging/print-live-message");
const plugins_customizations_1 = require("./plugins-customizations");
const lambda_1 = require("./faas/lambda");
const gcf_1 = require("./faas/gcf");
const AspectoHttpTraceContext_1 = require("./context/AspectoHttpTraceContext");
const RulesSampler_1 = require("./sampling/RulesSampler");
const require_order_check_1 = require("./utils/require-order-check");
const manualSpans = __importStar(require("./manual-spans"));
const aspecto_resource_1 = require("./aspecto-resource");
const opentelemetry_base_1 = require("@aspecto/opentelemetry-base");
const MessageProcessSampler_1 = require("./sampling/MessageProcessSampler");
const propagator_b3_1 = require("@opentelemetry/propagator-b3");
const opentelemetry_propagator_selective_1 = require("opentelemetry-propagator-selective");
const logDebugInit = debug_1.default('aspecto:init');
const initWithRemoteConfig = async (aspectoPrivacyProcessor, options, onSamplingRules) => {
    var _a, _b, _c;
    await config_1.ConfigService.connect(config_1.AspectoConfig.token);
    onSamplingRules && config_1.ConfigService.subscribeToSamplingRules(onSamplingRules);
    const { otCollectorUrl } = await config_1.ConfigService.getConfig();
    try {
        const aspectoOtEndpoint = config_1.getOtlpCollectorEndpoint((_c = (_b = (_a = options.otCollectorEndpoint) !== null && _a !== void 0 ? _a : options.otlpCollectorEndpoint) !== null && _b !== void 0 ? _b : process.env.OTEL_EXPORTER_OTLP_TRACES_ENDPOINT) !== null && _c !== void 0 ? _c : otCollectorUrl);
        const CollectorTraceExporter = process.env.ASPECTO_TRACE_EXPORT_JSON
            ? exporter_trace_otlp_http_1.OTLPTraceExporter
            : exporter_trace_otlp_proto_1.OTLPTraceExporter;
        const collectorTraceExporter = new CollectorTraceExporter({
            url: aspectoOtEndpoint,
        });
        aspectoPrivacyProcessor.setBatchExporter(collectorTraceExporter, config_1.AspectoConfig.exportBatchSize, config_1.AspectoConfig.exportBatchTimeoutMs);
    }
    catch (err) {
        console.log(`Aspecto Opentelemetry Tracer Error: ${err}`);
    }
    config_1.ConfigService.subscribeToDataCollectionRules(aspectoPrivacyProcessor.newDataCollectionRules.bind(aspectoPrivacyProcessor));
};
const addCustomZipkinExporter = (aspectoProcessor, options) => {
    if (!(options === null || options === void 0 ? void 0 : options.customZipkinEndpoint))
        return;
    aspectoProcessor.addExporter(new exporter_zipkin_1.ZipkinExporter({
        url: options.customZipkinEndpoint,
        serviceName: config_1.AspectoConfig.serviceName,
    }));
};
const aspectoInstrumentResult = Symbol.for('aspecto-instrument-result');
const instrument = (options = {}) => {
    var _a, _b;
    // prevent re-instrumenting.
    if (global[aspectoInstrumentResult]) {
        logDebugInit('Already instrumented, returning existing result.');
        return global[aspectoInstrumentResult];
    }
    try {
        if (!config_1.initializeConfig(options)) {
            logDebugInit('Config not initialized, exiting...');
            return;
        }
        if (options.disableAspecto || process.env.DISABLE_ASPECTO || config_1.AspectoConfig.jsonConfig.disableAspecto) {
            logDebugInit('DISABLE_ASPECTO=true, instrumentation skipped.');
            return {
                gcf: (h) => h,
                lambda: (h) => h,
                tracer: api_1.trace.getTracer(null),
                setLogger: () => { },
                shutdown: () => Promise.resolve(),
            };
        }
        const orderCheckResult = require_order_check_1.checkForRequireOrder();
        const rulesSampler = new RulesSampler_1.RulesSampler(config_1.AspectoConfig.samplingRatio, config_1.AspectoConfig.serviceName, config_1.AspectoConfig.deploymentEnvironment, config_1.AspectoConfig.requireConfigForTraces);
        if (options.writeSystemLogs) {
            api_1.diag.setLogger((_a = options.logger) !== null && _a !== void 0 ? _a : new api_1.DiagConsoleLogger(), api_1.DiagLogLevel.ALL);
        }
        logDebugInit('Creating provider...');
        const provider = new sdk_trace_node_1.NodeTracerProvider({
            resource: config_1.AspectoConfig.otelResource,
            sampler: new MessageProcessSampler_1.MessagingProcessSampler(rulesSampler, new core_1.ParentBasedSampler({
                root: rulesSampler,
            })),
        });
        logDebugInit('Loading plugins...');
        plugins_customizations_1.loadPlugins(provider);
        logDebugInit('Creating processor...');
        const aspectoProcessor = new AspectoProcessor_1.AspectoProcessor();
        addCustomZipkinExporter(aspectoProcessor, options);
        const serviceName = config_1.AspectoConfig.serviceName;
        if (!options.disableLiveStreamTraces) {
            logDebugInit('Initializing live stream traces mode...');
            const otelDiag = new opentelemetry_diag_1.OtelDiag({
                serviceName: config_1.AspectoConfig.serviceName,
                instanceId: config_1.AspectoConfig.serviceInstanceId,
                aspectoAuth: config_1.AspectoConfig.token,
            });
            setTimeout(async () => {
                try {
                    logDebugInit('Initializing otel diag...');
                    const otelDiagInfo = await otelDiag.init();
                    logDebugInit('Otel diag initialized successfully.', { otelDiagInfo });
                    otelDiag.addSdkEvent({
                        type: 'aspecto-version',
                        payload: {
                            packageName: serviceName,
                            version: config_1.AspectoConfig.aspectoVersion,
                        },
                    });
                    if (orderCheckResult.error) {
                        otelDiag.addSdkEvent({
                            type: 'bad-require-order',
                            payload: {
                                packageName: serviceName,
                                missingModules: orderCheckResult.missingModules,
                            },
                        });
                    }
                    if (config_1.AspectoConfig.deploymentEnvironment === aspecto_resource_1.NOT_SET_ATTRIBUTE_VALUE) {
                        otelDiag.addSdkEvent({
                            type: 'env-not-set',
                            payload: { packageName: serviceName },
                        });
                    }
                    const baseUrl = options.baseUrl || 'https://app.aspecto.io';
                    print_live_message_1.printLiveStreamMessage({ baseUrl, otelDiagInfo });
                }
                catch (err) {
                    console.log(`Failed to initialize Aspecto live stream tracing. ${err}`);
                }
            });
        }
        initWithRemoteConfig(aspectoProcessor, options, (_b = rulesSampler === null || rulesSampler === void 0 ? void 0 : rulesSampler.setRules) === null || _b === void 0 ? void 0 : _b.bind(rulesSampler)).catch((err) => {
            var _a;
            ((_a = options.logger) !== null && _a !== void 0 ? _a : console).warn(`Aspecto has encountered an error and will not instrument your service:\n  -  ${err.name}: ${err.message}`);
            provider.shutdown();
        });
        provider.addSpanProcessor(aspectoProcessor);
        provider.register({
            propagator: new core_1.CompositePropagator({
                propagators: [
                    new AspectoHttpTraceContext_1.AspectoHttpTraceContext(),
                    new opentelemetry_propagator_selective_1.SelectivePropagator(new propagator_b3_1.B3Propagator({ injectEncoding: propagator_b3_1.B3InjectEncoding.SINGLE_HEADER }), {
                        extractEnabled: config_1.AspectoConfig.extractB3Context,
                        injectEnabled: config_1.AspectoConfig.injectB3ContextSingleHeader,
                    }),
                    new opentelemetry_propagator_selective_1.SelectivePropagator(new propagator_b3_1.B3Propagator({ injectEncoding: propagator_b3_1.B3InjectEncoding.MULTI_HEADER }), {
                        injectEnabled: config_1.AspectoConfig.injectB3ContextMultiHeader,
                    }),
                ],
            }),
        });
        global[aspectoInstrumentResult] = {
            tracer: api_1.trace.getTracer(serviceName),
            lambda: lambda_1.getLambdaTracer(aspectoProcessor.forceFlush.bind(aspectoProcessor)),
            gcf: gcf_1.getGcfTracer(aspectoProcessor.forceFlush.bind(aspectoProcessor)),
            setLogger: (_logger) => { },
            shutdown: async () => {
                await aspectoProcessor.shutdown();
            },
        };
        logDebugInit('Aspecto instrumentation initialized successfully.');
        return global[aspectoInstrumentResult];
    }
    catch (e) {
        console.log(`Failed to initialize Aspecto tracing. ${e}`);
    }
};
const getContext = () => {
    try {
        const { traceId, spanId, traceFlags } = api_1.trace.getSpan(api_1.context.active()).spanContext();
        return { traceId, spanId, sampled: Boolean(traceFlags & api_1.TraceFlags.SAMPLED) };
    }
    catch (_a) {
        return { traceId: null, spanId: null, sampled: false };
    }
};
const handleSpanAttrKey = (key) => {
    if (!key || typeof key !== 'string')
        throw new Error('invalid span attribute key');
    const replaceSpaces = key.trim().replace(/\s+/g, '.');
    const withPrefix = `${opentelemetry_base_1.SetSpansAttributePrefix}.${replaceSpaces}`;
    return withPrefix;
};
const handleSpanAttrObjectKeys = (attributes) => {
    const newAttrObject = {};
    for (const [key, value] of Object.entries(attributes)) {
        const newKey = handleSpanAttrKey(key);
        newAttrObject[newKey] = value;
    }
    return newAttrObject;
};
/**
 * Sets an attribute to the span.
 * The key will get a prefix of 'aspecto.extra'.
 *
 * @param key the key for this attribute.
 * @param value the value for this attribute. Setting a value null or undefined is invalid and will result in undefined behavior.
 * @returns boolean for success/failure.
 */
const setAttribute = (key, value) => {
    try {
        const currentSpan = api_1.trace.getSpan(api_1.context.active());
        if (!currentSpan) {
            logDebugInit('setAttribute: the current span is undefined');
            return false;
        }
        const newKey = handleSpanAttrKey(key);
        currentSpan.setAttribute(newKey, value);
        return true;
    }
    catch (e) {
        logDebugInit(`setAttribute: Failed to set a new attribute on the current span: ${e}`);
        return false;
    }
};
/**
 * Sets attributes to the span with a prefix of 'aspecto.extra' on the keys.
 *
 * @param attributes the attributes that will be added. null or undefined attribute values are invalid and will result in undefined behavior.
 * @returns boolean for success/failure.
 */
const setAttributes = (attributes) => {
    try {
        const currentSpan = api_1.trace.getSpan(api_1.context.active());
        if (!currentSpan) {
            logDebugInit('setAttributes: the current span is undefined');
            return false;
        }
        const newAttrObject = handleSpanAttrObjectKeys(attributes);
        currentSpan.setAttributes(newAttrObject);
        return true;
    }
    catch (e) {
        logDebugInit(`setAttributes: Failed to set a new attributes on the current span: ${e}`);
        return false;
    }
};
instrument.getContext = getContext;
instrument.trace = manualSpans.trace;
instrument.setAttribute = setAttribute;
instrument.setAttributes = setAttributes;
module.exports = instrument;
//# sourceMappingURL=index.js.map
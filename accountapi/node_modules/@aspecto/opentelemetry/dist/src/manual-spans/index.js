"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.trace = void 0;
const opentelemetry = __importStar(require("@opentelemetry/api"));
const api_1 = require("@opentelemetry/api");
const opentelemetry_base_1 = require("@aspecto/opentelemetry-base");
const version_1 = require("../version");
const types_1 = require("./types");
const is_promise_1 = __importDefault(require("is-promise"));
const capture_stack_trace_1 = require("./capture-stack-trace");
__exportStar(require("./types"), exports);
const metadataNameToAttributeName = (metadataName) => {
    const normalizedMetadataName = metadataName.trim().replace(/\s+/g, '.');
    return `${opentelemetry_base_1.ManualSpansAttributePrefix}.${normalizedMetadataName}`;
};
const metadataToAttributes = (metadata) => {
    return Object.fromEntries(Object.entries(metadata).map(([k, v]) => [metadataNameToAttributeName(k), v]));
};
const spanToManualSpan = (span) => {
    return {
        addMetadata: (metadataName, metadataValue) => addMetadata(span, metadataName, metadataValue),
    };
};
const endSpanCallback = (fn, span, manualSpan) => {
    const doneCallback = (err) => {
        if (err) {
            if (typeof err === 'string') {
                span.setStatus({ code: api_1.SpanStatusCode.ERROR, message: err });
            }
            else {
                span.recordException(err);
                span.setStatus({ code: api_1.SpanStatusCode.ERROR, message: err === null || err === void 0 ? void 0 : err.message });
            }
        }
        span.end();
    };
    try {
        return fn(manualSpan, doneCallback);
    }
    catch (err) {
        span.recordException(err);
        span.setStatus({ code: api_1.SpanStatusCode.ERROR, message: err === null || err === void 0 ? void 0 : err.message });
        span.end();
        throw err;
    }
};
const endSpanOnSyncOrPromise = (fn, span, manualSpan) => {
    try {
        const fnResult = fn(manualSpan);
        if (is_promise_1.default(fnResult)) {
            return Promise.resolve(fnResult)
                .catch((err) => {
                if (err) {
                    if (typeof err === 'string') {
                        span.setStatus({ code: api_1.SpanStatusCode.ERROR, message: err });
                    }
                    else {
                        span.recordException(err);
                        span.setStatus({ code: api_1.SpanStatusCode.ERROR, message: err === null || err === void 0 ? void 0 : err.message });
                    }
                }
                throw err;
            })
                .finally(() => {
                span.end();
            });
        }
        else {
            span.end();
            return fnResult;
        }
    }
    catch (err) {
        span.recordException(err);
        span.setStatus({ code: api_1.SpanStatusCode.ERROR, message: err === null || err === void 0 ? void 0 : err.message });
        span.end();
        throw err;
    }
};
// export function trace(fn: TracedFunction);
exports.trace = (optionsOrTracedFunction, fn) => {
    var _a, _b;
    let options;
    if (typeof optionsOrTracedFunction === 'function') {
        fn = optionsOrTracedFunction;
        options = {};
    }
    else {
        options = optionsOrTracedFunction;
    }
    const tracer = opentelemetry.trace.getTracer(types_1.TRACER_NAME, version_1.VERSION);
    const attributes = metadataToAttributes((_a = options.metadata) !== null && _a !== void 0 ? _a : {});
    if (options.type) {
        attributes[opentelemetry_base_1.AspectoAttributeNames.ASPECTO_MANUAL_TYPE] = options.type;
    }
    const span = tracer.startSpan((_b = options.name) !== null && _b !== void 0 ? _b : '', { attributes });
    capture_stack_trace_1.captureCallStackTrace(span);
    const manualSpan = spanToManualSpan(span);
    return opentelemetry.context.with(opentelemetry.trace.setSpan(opentelemetry.context.active(), span), () => {
        // first parameter is always the span
        if (fn.length > 1) {
            return endSpanCallback(fn, span, manualSpan);
        }
        else {
            return endSpanOnSyncOrPromise(fn, span, manualSpan);
        }
    });
};
const addMetadata = (span, metadataName, metadataValue) => {
    let attributeValue;
    if (typeof metadataValue === 'object') {
        try {
            attributeValue = JSON.stringify(attributeValue);
        }
        catch (_a) {
            opentelemetry.diag.warn('aspecto manual instrumentation: could not JSON.stringify object metadata');
            return;
        }
    }
    span.setAttribute(metadataNameToAttributeName(metadataName), metadataValue);
};
//# sourceMappingURL=index.js.map
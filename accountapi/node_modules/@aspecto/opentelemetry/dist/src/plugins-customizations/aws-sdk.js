"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAspectoAwsSdkPluginConfig = void 0;
const opentelemetry_base_1 = require("@aspecto/opentelemetry-base");
const recording_span_1 = require("./recording-span");
const config_1 = require("../config");
const whiteListParams = {
    sqs: ['QueueUrl', 'DelaySeconds', 'MaxNumberOfMessages', 'WaitTimeSeconds'],
    s3: ['Bucket', 'Key', 'ACL', 'ContentType', 'ResponseContentType'],
    sns: ['TopicArn'],
    kinesis: ['StreamName', 'PartitionKey'],
    firehose: ['DeliveryStreamName'],
    ebs: ['SnapshotId'],
    ssm: ['Name'],
    lambda: ['FunctionName'],
    athena: ['WorkGroup', 'QueryString'],
    sts: ['RoleArn'],
};
const getRequestWhitelistedParams = (serviceName, requestParams) => {
    const paramsToCapture = whiteListParams[serviceName.toLowerCase()];
    if (!paramsToCapture || !requestParams)
        return;
    return paramsToCapture.reduce((whiteListParams, currParamName) => {
        const val = requestParams[currParamName];
        if (val !== undefined) {
            whiteListParams[currParamName] = val;
        }
        return whiteListParams;
    }, {});
};
const addSqsPayload = (span, request) => {
    var _a, _b, _c;
    let payload;
    switch (request.commandName) {
        case 'SendMessage': {
            payload = (_a = request.commandInput) === null || _a === void 0 ? void 0 : _a.MessageBody;
            if (typeof payload !== 'string')
                return;
            break;
        }
        case 'SendMessageBatch': {
            let messagesPayload = (_c = (_b = request.commandInput) === null || _b === void 0 ? void 0 : _b.Entries) === null || _c === void 0 ? void 0 : _c.map((entry) => ({
                msgId: entry.Id,
                payload: entry.MessageBody,
            }));
            try {
                payload = JSON.stringify(messagesPayload);
            }
            catch (_d) { }
            break;
        }
    }
    if (payload === undefined)
        return;
    span.setAttribute(opentelemetry_base_1.AspectoAttributeNames.MESSAGING_PAYLOAD, payload);
};
const awsSdkRequestHook = (span, requestInfo) => {
    span.setAttribute(opentelemetry_base_1.AspectoAttributeNames.MODULE_VERSION, requestInfo.moduleVersion);
    const paramsToAttach = getRequestWhitelistedParams(requestInfo.request.serviceName, requestInfo.request.commandInput);
    if (paramsToAttach) {
        try {
            span.setAttribute("aws.request.params" /* AWS_REQUEST_PARAMS */, JSON.stringify(paramsToAttach));
        }
        catch (_a) { }
    }
    switch (requestInfo.request.serviceName) {
        case 'SQS':
            if (recording_span_1.shouldCapturePayload(span)) {
                addSqsPayload(span, requestInfo.request);
            }
            break;
    }
};
const awsSdkResponseHook = (span, responseInfo) => {
    var _a, _b, _c;
    const { response } = responseInfo;
    switch (response.request.serviceName) {
        case 'DynamoDB':
            if (typeof response.data !== 'object')
                return;
            if (recording_span_1.shouldCapturePayload(span)) {
                span.setAttribute(opentelemetry_base_1.AspectoAttributeNames.DB_RESPONSE, JSON.stringify(response.data));
            }
            break;
        case 'SQS':
            if (response.request.commandName === 'ReceiveMessage') {
                const numOfMessages = (_c = (_b = (_a = response.data) === null || _a === void 0 ? void 0 : _a.Messages) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;
                span.setAttribute(opentelemetry_base_1.MessagingExtendedAttribute.MESSAGING_NUMBER_OF_MESSAGES, numOfMessages);
            }
            break;
    }
};
const sqsProcessCapturePayload = (span, sqsProcessInfo) => {
    var _a;
    const payload = (_a = sqsProcessInfo.message) === null || _a === void 0 ? void 0 : _a.Body;
    if (payload === undefined)
        return;
    span.setAttribute(opentelemetry_base_1.AspectoAttributeNames.MESSAGING_PAYLOAD, payload);
};
// making it a function instead of object so it evaluate AspectoConfig options at right time
exports.getAspectoAwsSdkPluginConfig = () => ({
    preRequestHook: awsSdkRequestHook,
    responseHook: awsSdkResponseHook,
    sqsProcessHook: recording_span_1.callCapturePayloadHook(sqsProcessCapturePayload),
    suppressInternalInstrumentation: true,
    sqsExtractContextPropagationFromPayload: config_1.AspectoConfig.sqsExtractContextPropagationFromPayload,
});
//# sourceMappingURL=aws-sdk.js.map
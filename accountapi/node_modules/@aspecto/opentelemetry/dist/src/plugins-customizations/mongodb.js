"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.aspectoMongodbPluginConfig = void 0;
const object_sizeof_1 = __importDefault(require("object-sizeof"));
const opentelemetry_base_1 = require("@aspecto/opentelemetry-base");
const recording_span_1 = require("./recording-span");
const AGGREGATE_CURSOR_PAYLOAD = Symbol('opentelemetry.mongodb.aggregate-cursor-payload');
const AGGREGATE_CURSOR_PAYLOAD_SIZE = Symbol('opentelemetry.mongodb.aggregate-cursor-payload-size');
const IS_AGGREGATE_CURSOR_PAYLOAD_FREEZED = Symbol('opentelemetry.mongodb.aggregate-cursor-payload-freezed');
const AGGREGATE_PAYLOAD_SIZE_LIMIT = 500 * 1024; // 500 KB
const getStatement = (operation, payload) => {
    var _a, _b, _c;
    if (operation === 'insert') {
        // for insert/insertMany operations the payload contains inserted documents
        return Array.isArray(payload) && payload.length === 1 ? payload[0] : payload;
    }
    if ((operation === 'update' || operation === 'remove') && Array.isArray(payload)) {
        // for update and remove the payload is an array with one element (query + update + opts)
        payload = payload[0];
    }
    // parse query (aka filter) and update statements from the payload
    const query = (_b = (_a = payload.query) !== null && _a !== void 0 ? _a : payload.q) !== null && _b !== void 0 ? _b : payload;
    const update = (_c = payload.update) !== null && _c !== void 0 ? _c : payload.u;
    return update ? { query, update } : query;
};
const dbStatementSerializer = (operation, payload) => {
    try {
        return JSON.stringify(getStatement(operation, payload));
    }
    catch (_a) {
        return undefined;
    }
};
const parsePayload = (payload) => {
    var _a, _b, _c, _d, _e, _f;
    if (!payload || Array.isArray(payload) || typeof payload !== 'object')
        return payload;
    return (_f = (_e = (_c = (_b = (_a = payload.result) === null || _a === void 0 ? void 0 : _a.cursor) === null || _b === void 0 ? void 0 : _b.firstBatch) !== null && _c !== void 0 ? _c : (_d = payload.cursor) === null || _d === void 0 ? void 0 : _d.nextBatch) !== null && _e !== void 0 ? _e : payload.result) !== null && _f !== void 0 ? _f : payload;
};
const responseHook = (span, response) => {
    const payload = parsePayload(response);
    span.setAttribute(opentelemetry_base_1.AspectoAttributeNames.DB_RESPONSE, JSON.stringify(payload));
};
const aggregateGetMoreResponseHook = (span, responseInfo) => {
    var _a, _b;
    const cursorState = responseInfo.cursorState;
    const payload = parsePayload(responseInfo.payload);
    const aggregatedPayload = (_a = cursorState[AGGREGATE_CURSOR_PAYLOAD]) !== null && _a !== void 0 ? _a : [];
    const aggregatedPayloadSize = (_b = cursorState[AGGREGATE_CURSOR_PAYLOAD_SIZE]) !== null && _b !== void 0 ? _b : 0;
    const isAggregatedPayloadFreezed = Boolean(cursorState[IS_AGGREGATE_CURSOR_PAYLOAD_FREEZED]);
    if (payload && !isAggregatedPayloadFreezed) {
        const calcAggregatedPayloadSize = aggregatedPayloadSize + object_sizeof_1.default(payload);
        if (calcAggregatedPayloadSize < AGGREGATE_PAYLOAD_SIZE_LIMIT) {
            if (Array.isArray(payload)) {
                aggregatedPayload.push(...payload);
            }
            else {
                aggregatedPayload.push(payload);
            }
            cursorState[AGGREGATE_CURSOR_PAYLOAD] = aggregatedPayload;
            cursorState[AGGREGATE_CURSOR_PAYLOAD_SIZE] = calcAggregatedPayloadSize;
        }
        else {
            cursorState[IS_AGGREGATE_CURSOR_PAYLOAD_FREEZED] = true;
        }
    }
    if (cursorState.dead) {
        // store aggregated response payload to a span when a cursor is closed.
        span.setAttribute(opentelemetry_base_1.AspectoAttributeNames.DB_RESPONSE, JSON.stringify(aggregatedPayload));
    }
};
exports.aspectoMongodbPluginConfig = {
    dbStatementSerializer,
    responseHook: recording_span_1.callCapturePayloadHook(responseHook),
    moduleVersionAttributeName: opentelemetry_base_1.AspectoAttributeNames.MODULE_VERSION,
    ignoreIsMasterCommand: true,
    aggregateGetMoreOperations: true,
    aggregateGetMoreResponseHook: recording_span_1.callCapturePayloadHook(aggregateGetMoreResponseHook),
};
//# sourceMappingURL=mongodb.js.map
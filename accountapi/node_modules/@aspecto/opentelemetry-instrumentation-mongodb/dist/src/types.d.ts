import { Span } from '@opentelemetry/api';
import { InstrumentationConfig } from '@opentelemetry/instrumentation';
export declare type DbStatementSerializer = (operation: string, payload: any) => string;
export declare type MongoDbResponseCustomAttributesFunction = (span: Span, response: any) => void;
export declare type MongoDbGetMoreResponseHookInformation = {
    payload?: any;
    cursorState?: CursorState;
};
export declare type MongoDbGetMoreResponseAggregateFunction = (span: Span, responseInfo: MongoDbGetMoreResponseHookInformation) => void;
export interface MongoDbInstrumentationConfig extends InstrumentationConfig {
    /** Custom serializer function for the db.statement tag */
    dbStatementSerializer?: DbStatementSerializer;
    /** hook for adding custom attributes using the response payload */
    responseHook?: MongoDbResponseCustomAttributesFunction;
    /**
     * If passed, a span attribute will be added to all spans with key of the provided "moduleVersionAttributeName"
     * and value of the module version.
     */
    moduleVersionAttributeName?: string;
    /** Require parent to create mongodb span, default when unset is true */
    requireParentSpan?: boolean;
    /** If true, a span for periodical isMaster command will not be generated, default when unset is false */
    ignoreIsMasterCommand?: boolean;
    /** If true, a span for a `getMore` command will not be generated, default when unset is false */
    aggregateGetMoreOperations?: boolean;
    /** hook for aggregate a response payload of a GetMore operation, applicable only when `aggregateGetMoreOperations` config option is true */
    aggregateGetMoreResponseHook?: MongoDbGetMoreResponseAggregateFunction;
}
export declare type Func<T> = (...args: unknown[]) => T;
export declare type MongoInternalCommand = {
    aggregate: string;
    findAndModify: string;
    createIndexes: string;
    listIndexes: string;
    count: boolean;
    ismaster: boolean;
    indexes?: unknown[];
    query?: Record<string, unknown>;
    limit?: number;
    q?: Record<string, unknown>;
    u?: Record<string, unknown>;
};
export declare type MongoCommandOptions = {
    session?: {
        owner?: {
            cursorState: CursorState;
        };
    };
};
export declare type CursorState = {
    cmd: MongoInternalCommand;
    batchSize: number;
} & Record<string, unknown>;
export declare type WireProtocolInternal = {
    insert: (server: MongoInternalTopology, ns: string, ops: unknown[], options: unknown | Function, callback?: Function) => unknown;
    update: (server: MongoInternalTopology, ns: string, ops: unknown[], options: unknown | Function, callback?: Function) => unknown;
    remove: (server: MongoInternalTopology, ns: string, ops: unknown[], options: unknown | Function, callback?: Function) => unknown;
    killCursors: (server: MongoInternalTopology, ns: string, cursorState: CursorState, callback: Function) => unknown;
    getMore: (server: MongoInternalTopology, ns: string, cursorState: CursorState, batchSize: number, options: unknown | Function, callback?: Function) => unknown;
    query: (server: MongoInternalTopology, ns: string, cmd: MongoInternalCommand, cursorState: CursorState, options: unknown | Function, callback?: Function) => unknown;
    command: (server: MongoInternalTopology, ns: string, cmd: MongoInternalCommand, options: unknown | Function, callback?: Function) => unknown;
};
export declare type MongoInternalTopology = {
    s?: {
        options?: {
            host?: string;
            port?: number;
            servername?: string;
        };
        host?: string;
        port?: number;
    };
    description?: {
        address?: string;
    };
};
export declare enum MongodbCommandType {
    CREATE_INDEXES = "createIndexes",
    FIND_AND_MODIFY = "findAndModify",
    LIST_INDEXES = "listIndexes",
    AGGREGATE = "aggregate",
    IS_MASTER = "isMaster",
    COUNT = "count",
    UNKNOWN = "unknown"
}
//# sourceMappingURL=types.d.ts.map
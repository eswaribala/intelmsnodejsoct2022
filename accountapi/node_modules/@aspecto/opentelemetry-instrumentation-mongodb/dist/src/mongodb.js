"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoDBInstrumentation = void 0;
const api_1 = require("@opentelemetry/api");
const types_1 = require("./types");
const version_1 = require("./version");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const instrumentation_1 = require("@opentelemetry/instrumentation");
const supportedVersions = ['>=3.3 <4'];
const DEFAULT_CONFIG = {
    requireParentSpan: true,
};
const AGGREGATE_CURSOR_SPAN = Symbol('opentelemetry.mongodb.aggregate-cursor-span');
/** mongodb instrumentation plugin for OpenTelemetry */
class MongoDBInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(_config = {}) {
        super('@aspecto/opentelemetry-instrumentation-mongodb', version_1.VERSION, Object.assign({}, DEFAULT_CONFIG, _config));
    }
    init() {
        const { patch, unpatch } = this._getModulePatches();
        const { patch: patchProtocol, unpatch: unpatchProtocol } = this._getWireProtocolPatches();
        return [
            new instrumentation_1.InstrumentationNodeModuleDefinition('mongodb', supportedVersions, patch, unpatch, [
                new instrumentation_1.InstrumentationNodeModuleFile('mongodb/lib/core/wireprotocol/index.js', supportedVersions, patchProtocol, unpatchProtocol),
            ]),
        ];
    }
    _getModulePatches() {
        return {
            patch: (moduleExports, moduleVersion) => {
                var _a;
                this.moduleVersion = moduleVersion;
                if (((_a = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.Cursor) === null || _a === void 0 ? void 0 : _a.prototype) == undefined)
                    return moduleExports;
                api_1.diag.debug(`Applying patch for mongodb@${moduleVersion}`);
                // patch close operation
                if (instrumentation_1.isWrapped(moduleExports.Cursor.prototype.close)) {
                    this._unwrap(moduleExports.Cursor.prototype, 'close');
                }
                this._wrap(moduleExports.Cursor.prototype, 'close', this._getPatchCursorClose());
                return moduleExports;
            },
            unpatch: (moduleExports, moduleVersion) => {
                var _a;
                if (((_a = moduleExports === null || moduleExports === void 0 ? void 0 : moduleExports.Cursor) === null || _a === void 0 ? void 0 : _a.prototype) == undefined)
                    return;
                api_1.diag.debug(`Removing internal patch for mongodb@${moduleVersion}`);
                this._unwrap(moduleExports.Cursor.prototype, 'close');
            },
        };
    }
    _getWireProtocolPatches() {
        return {
            patch: (moduleExports, moduleVersion) => {
                api_1.diag.debug(`Applying patch for wire protocol mongodb@${moduleVersion}`);
                this.moduleVersion = moduleVersion;
                // patch insert operation
                if (instrumentation_1.isWrapped(moduleExports.insert)) {
                    this._unwrap(moduleExports, 'insert');
                }
                this._wrap(moduleExports, 'insert', this._getPatchOperation('insert'));
                // patch remove operation
                if (instrumentation_1.isWrapped(moduleExports.remove)) {
                    this._unwrap(moduleExports, 'remove');
                }
                this._wrap(moduleExports, 'remove', this._getPatchOperation('remove'));
                // patch update operation
                if (instrumentation_1.isWrapped(moduleExports.update)) {
                    this._unwrap(moduleExports, 'update');
                }
                this._wrap(moduleExports, 'update', this._getPatchOperation('update'));
                // patch other command
                if (instrumentation_1.isWrapped(moduleExports.command)) {
                    this._unwrap(moduleExports, 'command');
                }
                this._wrap(moduleExports, 'command', this._getPatchCommand());
                // patch query
                if (instrumentation_1.isWrapped(moduleExports.query)) {
                    this._unwrap(moduleExports, 'query');
                }
                this._wrap(moduleExports, 'query', this._getPatchFind());
                // patch get more operation on cursor
                if (instrumentation_1.isWrapped(moduleExports.getMore)) {
                    this._unwrap(moduleExports, 'getMore');
                }
                this._wrap(moduleExports, 'getMore', this._getPatchCursor());
                return moduleExports;
            },
            unpatch: (moduleExports, moduleVersion) => {
                if (moduleExports === undefined)
                    return;
                api_1.diag.debug(`Removing internal patch for wire protocol mongodb@${moduleVersion}`);
                this._unwrap(moduleExports, 'insert');
                this._unwrap(moduleExports, 'remove');
                this._unwrap(moduleExports, 'update');
                this._unwrap(moduleExports, 'command');
                this._unwrap(moduleExports, 'query');
                this._unwrap(moduleExports, 'getMore');
            },
        };
    }
    /** Ends a created span. */
    _getPatchCursorClose() {
        const instrumentation = this;
        return (original) => {
            return function patchedCursorClose(...args) {
                var _a;
                const span = this.cursorState[AGGREGATE_CURSOR_SPAN];
                if (span) {
                    instrumentation._applyGetMoreResponseHook(span, null, this.cursorState, (_a = instrumentation._config) === null || _a === void 0 ? void 0 : _a.aggregateGetMoreResponseHook);
                    span.end();
                }
                return original.apply(this, args);
            };
        };
    }
    /** Creates spans for common operations */
    _getPatchOperation(operationName) {
        const instrumentation = this;
        return (original) => {
            return function patchedServerCommand(server, ns, ops, options, callback) {
                var _a;
                const currentSpan = api_1.trace.getSpan(api_1.context.active());
                const resultHandler = typeof options === 'function' ? options : callback;
                if ((((_a = instrumentation._config) === null || _a === void 0 ? void 0 : _a.requireParentSpan) === true && !currentSpan) ||
                    typeof resultHandler !== 'function' ||
                    typeof ops !== 'object') {
                    return original.apply(this, arguments);
                }
                const span = instrumentation.tracer.startSpan(`mongodb.${operationName}`, {
                    kind: api_1.SpanKind.CLIENT,
                });
                instrumentation._populateAttributes(span, ns, operationName, server, ops);
                const patchedCallback = instrumentation._patchEnd(span, resultHandler);
                // handle when options is the callback to send the correct number of args
                if (typeof options === 'function') {
                    return original.call(this, server, ns, ops, patchedCallback);
                }
                else {
                    return original.call(this, server, ns, ops, options, patchedCallback);
                }
            };
        };
    }
    /** Creates spans for command operation */
    _getPatchCommand() {
        const instrumentation = this;
        return (original) => {
            return function patchedServerCommand(server, ns, cmd, options, callback) {
                var _a, _b, _c, _d, _e, _f;
                const currentSpan = api_1.trace.getSpan(api_1.context.active());
                const resultHandler = typeof options === 'function' ? options : callback;
                const commandType = instrumentation._getCommandType(cmd);
                const shouldBeIgnored = commandType === types_1.MongodbCommandType.IS_MASTER && ((_a = instrumentation._config) === null || _a === void 0 ? void 0 : _a.ignoreIsMasterCommand);
                if ((((_b = instrumentation._config) === null || _b === void 0 ? void 0 : _b.requireParentSpan) === true && !currentSpan) ||
                    typeof resultHandler !== 'function' ||
                    typeof cmd !== 'object' ||
                    shouldBeIgnored) {
                    return original.apply(this, arguments);
                }
                const type = commandType === types_1.MongodbCommandType.UNKNOWN ? 'command' : commandType;
                const span = instrumentation.tracer.startSpan(`mongodb.${type}`, {
                    kind: api_1.SpanKind.CLIENT,
                });
                instrumentation._populateAttributes(span, ns, type, server, cmd);
                const isUsedCursor = commandType === types_1.MongodbCommandType.AGGREGATE || commandType === types_1.MongodbCommandType.LIST_INDEXES;
                const cursorState = (_e = (_d = (_c = options) === null || _c === void 0 ? void 0 : _c.session) === null || _d === void 0 ? void 0 : _d.owner) === null || _e === void 0 ? void 0 : _e.cursorState;
                let patchedCallback;
                if (isUsedCursor && ((_f = instrumentation._config) === null || _f === void 0 ? void 0 : _f.aggregateGetMoreOperations) === true && cursorState) {
                    cursorState[AGGREGATE_CURSOR_SPAN] = span;
                    patchedCallback = instrumentation._patchEndAggregated(span, resultHandler, cursorState);
                }
                else {
                    patchedCallback = instrumentation._patchEnd(span, resultHandler);
                }
                // handle when options is the callback to send the correct number of args
                if (typeof options === 'function') {
                    return original.call(this, server, ns, cmd, patchedCallback);
                }
                else {
                    return original.call(this, server, ns, cmd, options, patchedCallback);
                }
            };
        };
    }
    /** Creates spans for find operation */
    _getPatchFind() {
        const instrumentation = this;
        return (original) => {
            return function patchedServerCommand(server, ns, cmd, cursorState, options, callback) {
                var _a, _b;
                const currentSpan = api_1.trace.getSpan(api_1.context.active());
                const resultHandler = typeof options === 'function' ? options : callback;
                if ((((_a = instrumentation._config) === null || _a === void 0 ? void 0 : _a.requireParentSpan) === true && !currentSpan) ||
                    typeof resultHandler !== 'function' ||
                    typeof cmd !== 'object') {
                    return original.apply(this, arguments);
                }
                const operationName = 'find';
                const span = instrumentation.tracer.startSpan(`mongodb.${operationName}`, {
                    kind: api_1.SpanKind.CLIENT,
                });
                instrumentation._populateAttributes(span, ns, operationName, server, cmd);
                let patchedCallback;
                // no need to aggregate in case when cursorState.batchSize less then one.
                if (((_b = instrumentation._config) === null || _b === void 0 ? void 0 : _b.aggregateGetMoreOperations) === true && cursorState.batchSize > 1) {
                    cursorState[AGGREGATE_CURSOR_SPAN] = span;
                    patchedCallback = instrumentation._patchEndAggregated(span, resultHandler, cursorState);
                }
                else {
                    patchedCallback = instrumentation._patchEnd(span, resultHandler);
                }
                // handle when options is the callback to send the correct number of args
                if (typeof options === 'function') {
                    return original.call(this, server, ns, cmd, cursorState, patchedCallback);
                }
                else {
                    return original.call(this, server, ns, cmd, cursorState, options, patchedCallback);
                }
            };
        };
    }
    /** Creates spans for getMore operation */
    _getPatchCursor() {
        const instrumentation = this;
        return (original) => {
            return function patchedServerCommand(server, ns, cursorState, batchSize, options, callback) {
                var _a, _b;
                const currentSpan = api_1.trace.getSpan(api_1.context.active());
                const resultHandler = typeof options === 'function' ? options : callback;
                if ((((_a = instrumentation._config) === null || _a === void 0 ? void 0 : _a.requireParentSpan) === true && !currentSpan) ||
                    typeof resultHandler !== 'function') {
                    return original.apply(this, arguments);
                }
                const underlyingCursorSpan = ((_b = instrumentation._config) === null || _b === void 0 ? void 0 : _b.aggregateGetMoreOperations) === true
                    ? cursorState[AGGREGATE_CURSOR_SPAN]
                    : undefined;
                let patchedCallback;
                if (underlyingCursorSpan) {
                    patchedCallback = instrumentation._patchEndAggregated(underlyingCursorSpan, resultHandler, cursorState);
                }
                else {
                    const operationName = 'getMore';
                    const span = instrumentation.tracer.startSpan(`mongodb.${operationName}`, {
                        kind: api_1.SpanKind.CLIENT,
                    });
                    instrumentation._populateAttributes(span, ns, operationName, server, cursorState.cmd);
                    patchedCallback = instrumentation._patchEnd(span, resultHandler);
                }
                // handle when options is the callback to send the correct number of args
                if (typeof options === 'function') {
                    return original.call(this, server, ns, cursorState, batchSize, patchedCallback);
                }
                else {
                    return original.call(this, server, ns, cursorState, batchSize, options, patchedCallback);
                }
            };
        };
    }
    /**
     * Get the mongodb command type from the object.
     * @param command Internal mongodb command object
     */
    _getCommandType(command) {
        if (command.createIndexes !== undefined) {
            return types_1.MongodbCommandType.CREATE_INDEXES;
        }
        else if (command.findAndModify !== undefined) {
            return types_1.MongodbCommandType.FIND_AND_MODIFY;
        }
        else if (command.ismaster !== undefined) {
            return types_1.MongodbCommandType.IS_MASTER;
        }
        else if (command.count !== undefined) {
            return types_1.MongodbCommandType.COUNT;
        }
        else if (command.listIndexes !== undefined) {
            return types_1.MongodbCommandType.LIST_INDEXES;
        }
        else if (command.aggregate !== undefined) {
            return types_1.MongodbCommandType.AGGREGATE;
        }
        else {
            return types_1.MongodbCommandType.UNKNOWN;
        }
    }
    /**
     * Populate span's attributes by fetching related metadata from the context
     * @param span span to add attributes to
     * @param ns mongodb namespace
     * @param command mongodb internal representation of a command
     * @param topology mongodb internal representation of the network topology
     */
    _populateAttributes(span, ns, operation, topology, command) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        // add network attributes to determine the remote server
        if ((_a = topology.description) === null || _a === void 0 ? void 0 : _a.address) {
            const [host, port] = (_b = topology.description.address.split(':')) !== null && _b !== void 0 ? _b : [];
            span.setAttributes({
                [semantic_conventions_1.SemanticAttributes.NET_PEER_NAME]: host,
                [semantic_conventions_1.SemanticAttributes.NET_PEER_PORT]: parseInt(port, 10),
            });
        }
        else if (topology && topology.s) {
            span.setAttributes({
                [semantic_conventions_1.SemanticAttributes.NET_PEER_NAME]: (_d = (_c = topology.s.options) === null || _c === void 0 ? void 0 : _c.host) !== null && _d !== void 0 ? _d : topology.s.host,
                [semantic_conventions_1.SemanticAttributes.NET_PEER_PORT]: (_f = (_e = topology.s.options) === null || _e === void 0 ? void 0 : _e.port) !== null && _f !== void 0 ? _f : topology.s.port,
            });
        }
        // The namespace is a combination of the database name and the name of the
        // collection or index, like so: [database-name].[collection-or-index-name].
        // It could be a string or an instance of MongoDBNamespace, as such we
        // always coerce to a string to extract db and collection.
        const [dbName, dbCollection] = ns.toString().split('.');
        const collection = (_g = this._getCollectionNameByCommand(command)) !== null && _g !== void 0 ? _g : dbCollection;
        // add database related attributes
        span.setAttributes({
            [semantic_conventions_1.SemanticAttributes.DB_OPERATION]: operation,
            [semantic_conventions_1.SemanticAttributes.DB_SYSTEM]: 'mongodb',
            [semantic_conventions_1.SemanticAttributes.DB_NAME]: dbName,
            [semantic_conventions_1.SemanticAttributes.DB_MONGODB_COLLECTION]: collection,
        });
        if (this._config.moduleVersionAttributeName) {
            span.setAttribute(this._config.moduleVersionAttributeName, this.moduleVersion);
        }
        if (command === undefined)
            return;
        const dbStatementSerializer = ((_h = this._config) === null || _h === void 0 ? void 0 : _h.dbStatementSerializer) || this._defaultDbStatementSerializer.bind(this);
        span.setAttribute(semantic_conventions_1.SemanticAttributes.DB_STATEMENT, dbStatementSerializer(operation, command));
    }
    /**
     * Ends a created span.
     * @param span The created span to end.
     * @param resultHandler A callback function.
     */
    _patchEnd(span, resultHandler) {
        const instrumentation = this;
        // mongodb is using "tick" when calling a callback, this way the context
        // in final callback (resultHandler) is lost
        const activeContext = api_1.context.active();
        return function patchedEnd(...args) {
            var _a;
            const error = args[0];
            if (error instanceof Error) {
                span.recordException(error);
                span.setStatus({
                    code: api_1.SpanStatusCode.ERROR,
                    message: error.message,
                });
            }
            if (!error) {
                instrumentation._applyResponseHook(span, args[1], (_a = instrumentation._config) === null || _a === void 0 ? void 0 : _a.responseHook);
            }
            span.end();
            return api_1.context.with(activeContext, () => {
                return resultHandler.apply(this, args);
            });
        };
    }
    /**
     * Ends a created span.
     * @param span The created span to end.
     * @param resultHandler A callback function.
     * @param payload An aggregated payload.
     */
    _patchEndAggregated(span, resultHandler, cursorState) {
        const instrumentation = this;
        // mongodb is using "tick" when calling a callback, this way the context
        // in final callback (resultHandler) is lost
        const activeContext = api_1.context.active();
        return function patchedEnd(...args) {
            var _a;
            const [error, payload] = args;
            if (error instanceof Error) {
                span.recordException(error);
                span.setStatus({
                    code: api_1.SpanStatusCode.ERROR,
                    message: error.message,
                });
                span.end();
            }
            else if (((_a = instrumentation._config) === null || _a === void 0 ? void 0 : _a.aggregateGetMoreResponseHook) && payload) {
                instrumentation._applyGetMoreResponseHook(span, payload, cursorState, instrumentation._config.aggregateGetMoreResponseHook);
            }
            return api_1.context.with(activeContext, () => {
                return resultHandler.apply(this, args);
            });
        };
    }
    _defaultDbStatementSerializer(operation, command) {
        let statement = this._getStatement(operation, command);
        if (Array.isArray(statement)) {
            statement = statement.map((obj) => this._defaultObjectSerializer(obj));
        }
        else {
            statement = this._defaultObjectSerializer(statement);
        }
        try {
            return JSON.stringify(statement);
        }
        catch (e) {
            api_1.diag.error('mongodb instrumentation: defaultDbStatementSerializer error', e);
            return undefined;
        }
    }
    _defaultObjectSerializer(obj) {
        return Object.keys(obj).reduce((obj, key) => {
            obj[key] = '?';
            return obj;
        }, {});
    }
    _getStatement(operation, payload) {
        var _a, _b;
        if (operation === 'insert') {
            // for insert, insertMany operations the payload contains inserted documents
            return Array.isArray(payload) && payload.length === 1 ? payload[0] : payload;
        }
        if ((operation === 'update' || operation === 'remove') && Array.isArray(payload)) {
            // for update and remove operations the payload is an array with one element (query + update + opts)
            payload = payload[0];
        }
        // parse query (aka filter) and update statements from the payload
        return (_b = (_a = payload.query) !== null && _a !== void 0 ? _a : payload.q) !== null && _b !== void 0 ? _b : payload;
    }
    _applyResponseHook(span, response, responseHook) {
        if (responseHook) {
            instrumentation_1.safeExecuteInTheMiddle(() => responseHook(span, response), (e) => {
                if (e) {
                    api_1.diag.error('mongodb instrumentation: responseHook error', e);
                }
            }, true);
        }
    }
    _applyGetMoreResponseHook(span, payload, cursorState, getMoreResponseHook) {
        if (getMoreResponseHook) {
            instrumentation_1.safeExecuteInTheMiddle(() => getMoreResponseHook(span, { payload, cursorState }), (e) => {
                if (e) {
                    api_1.diag.error('mongodb instrumentation: getMoreResponseHook error', e);
                }
            }, true);
        }
    }
    _getCollectionNameByCommand(command) {
        if (!command)
            return undefined;
        const commandType = this._getCommandType(command);
        if (commandType === types_1.MongodbCommandType.AGGREGATE)
            return command.aggregate;
        if (commandType === types_1.MongodbCommandType.LIST_INDEXES)
            return command.listIndexes;
        if (commandType === types_1.MongodbCommandType.CREATE_INDEXES)
            return command.createIndexes;
        if (commandType === types_1.MongodbCommandType.FIND_AND_MODIFY)
            return command.findAndModify;
    }
}
exports.MongoDBInstrumentation = MongoDBInstrumentation;
//# sourceMappingURL=mongodb.js.map
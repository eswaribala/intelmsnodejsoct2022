"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterRulesByPackageNameAndEnv = exports.meetsOperator = void 0;
const types_1 = require("./types");
const meetsOperator = (operator, expected, actual) => {
    try {
        const expectedLower = typeof expected === 'string' ? expected.toLowerCase() : expected;
        const actualLower = typeof actual === 'string' ? actual.toLowerCase() : actual;
        switch (operator) {
            case types_1.Operator.ANY:
                return true;
            case types_1.Operator.DEFINED:
                return actual !== undefined;
            case types_1.Operator.UNDEFINED:
                return actual === undefined;
            case types_1.Operator.EQ:
                return expectedLower === actualLower;
            case types_1.Operator.NE:
                return expectedLower !== actualLower;
            case types_1.Operator.STARTS_WITH:
                return actualLower.startsWith(expectedLower);
            case types_1.Operator.ENDS_WITH:
                return actualLower.endsWith(expectedLower);
            case types_1.Operator.CONTAINS:
                return actualLower.includes(expectedLower);
            case types_1.Operator.NOT_CONTAINS:
                return !actualLower.includes(expectedLower);
            case types_1.Operator.MATCHES:
                const regex = new RegExp(expected);
                return regex.test(actual) || regex.test(actualLower);
            default:
                return false;
        }
    }
    catch (_a) {
        return false;
    }
};
exports.meetsOperator = meetsOperator;
const filterRulesByPackageNameAndEnv = (rules, packageName, env) => {
    return rules
        .filter((rule) => exports.meetsOperator(rule.packageName.comparison, rule.packageName.value, packageName))
        .filter((rule) => exports.meetsOperator(rule.env.comparison, rule.env.value, env));
};
exports.filterRulesByPackageNameAndEnv = filterRulesByPackageNameAndEnv;
//# sourceMappingURL=utils.js.map
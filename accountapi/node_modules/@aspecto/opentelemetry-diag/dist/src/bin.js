"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const ci_info_1 = require("ci-info");
const git_service_1 = require("./git.service");
const footprint_1 = require("./footprint");
const config_1 = require("./config");
const axios_1 = __importDefault(require("axios"));
const PKG_NAME = `@aspecto/opentelemetry`;
// used to identify our part in the existing hook
const ASPECTO_HOOK_COMMENT = `# aspecto hook`;
const HOOK_NAME = 'pre-push';
const HOOK_TIMEOUT_MS = 5000;
// leave 500ms to print the error message
axios_1.default.defaults.timeout = HOOK_TIMEOUT_MS - 500;
let exitTimeoutId;
// npx with "-p" parameter will work even if package isn't installed or node_modules were removed
// (which can happen in case of monorepo or when user runs 'rm -rf node_modules')
// but it is always slower as it doesn't use pre-installed version, so we use it -p when possible.
const sendFpCommand = [
    `if [ -f "$PWD/node_modules/.bin/aspecto-otel-live" ]; `,
    `then npx aspecto-otel-live send-push-event &> aspecto.log || true ; `,
    `else npx -p @aspecto/opentelemetry-diag aspecto-otel-live send-push-event &> aspecto.log || true ; fi `,
    `${ASPECTO_HOOK_COMMENT}`,
].join('');
function getHookContent() {
    return ['#!/bin/sh', sendFpCommand].join('\n');
}
const logger = {
    info(msg, ...params) {
        console.log(`${PKG_NAME} > ${msg}`, ...params);
    },
    error(msg, ...params) {
        console.error(`${PKG_NAME} > ${msg}`, ...params);
    },
};
function printUsage() {
    logger.info("Usage: npx aspecto-otel-live <action>. Supported actions: 'instal', 'uninstal', 'send-push-event'.");
}
// It may happen, that it's takes too much time to collect the data.
// we don't want to make the user wait for it during 'git push', so we exit on timeout.
// It is safer do to it like this for the whole process than just configuring axios timeouts.
function exitOnTimeout(timeoutInMs) {
    exitTimeoutId = setTimeout(() => {
        console.log(`Exiting on timeout (${timeoutInMs}ms)`);
        process.exit(1);
    }, timeoutInMs);
}
function exit(code) {
    if (exitTimeoutId) {
        clearTimeout(exitTimeoutId);
    }
    process.exit(code);
}
function run() {
    exitOnTimeout(HOOK_TIMEOUT_MS);
    if (process.argv.length < 3) {
        printUsage();
        exit();
    }
    exitIfShouldntRun();
    const action = process.argv[2];
    runAction(action)
        .then(() => {
        exit(0);
    })
        .catch(() => {
        exit(1);
    });
}
async function runAction(action) {
    try {
        switch (action) {
            case 'install':
                runInstall();
                logger.info('Done');
                break;
            case 'uninstall':
                runUninstall();
                logger.info('Done');
                break;
            case 'send-push-event':
                await sendPushEvent();
                logger.info('Done');
                break;
            default:
                logger.info(`Unknown action: ${action}`);
                printUsage();
        }
    }
    catch (err) {
        logger.error(`Failed to execute ${action} action`, err);
    }
}
function runInstall() {
    const hookPath = getHookPath();
    let newContent;
    if (fs_1.default.existsSync(hookPath)) {
        // husky and potentially some other hooks can exit from the hook before it reaches aspecto part (by executing exit command for example)
        // in order to overcome that, we insert our part as a first non-comment line in the hook source code
        const existingContent = fs_1.default.readFileSync(hookPath, { encoding: 'utf-8' });
        const lines = existingContent.replace(/^.+# aspecto hook\s*$/gim, '').split('\n');
        const firstNonCommentIdx = lines.findIndex((x) => !/^\s*#/gi.test(x));
        lines.splice(firstNonCommentIdx, 0, sendFpCommand, '\n');
        newContent = lines.join('\n');
    }
    else {
        newContent = getHookContent();
    }
    fs_1.default.writeFileSync(hookPath, newContent);
    fs_1.default.chmodSync(hookPath, 0o0755);
}
function runUninstall() {
    const hookPath = getHookPath();
    if (!fs_1.default.existsSync(hookPath))
        return;
    const existingContent = fs_1.default.readFileSync(hookPath, { encoding: 'utf-8' });
    const newContent = existingContent.replace(/^.+# aspecto hook\s*$/gim, '');
    fs_1.default.writeFileSync(hookPath, newContent);
}
async function sendPushEvent() {
    const footprint = await footprint_1.getFooprintForGitHook();
    const gitConfig = git_service_1.getGitConfig();
    const headSha = git_service_1.getGitHead();
    const commits = git_service_1.getPushCommits(headSha);
    const branch = git_service_1.getGitBranch();
    await axios_1.default.post(`https://${config_1.LIVE_FLOWS_HOST}/api/git/events`, {
        eventType: 'push',
        headSha,
        gitConfig,
        footprint,
        commits,
        branch,
    });
}
function exitIfShouldntRun() {
    try {
        if (['true', '1'].includes(process.env.ASPECTO_SKIP_HOOKS || '')) {
            logger.info(`ASPECTO_SKIP_HOOKS is set, skipping...`);
            exit(0);
        }
        if (ci_info_1.isCI) {
            logger.info(`CI environment detected, skipping...`);
            exit(0);
        }
        if (!git_service_1.isGitRepo()) {
            logger.info('Not a git repo, skipping...');
            exit(0);
        }
    }
    catch (err) {
        logger.error(`unhandled error, exiting...`, err);
        exit(0);
    }
}
function getHookPath() {
    const cwd = process.cwd();
    const { gitCommonDir } = git_service_1.gitRevParse(cwd);
    const absoluteGitCommonDir = path_1.default.resolve(cwd, gitCommonDir);
    const prePushHookPath = path_1.default.join(absoluteGitCommonDir, 'hooks', HOOK_NAME);
    return prePushHookPath;
}
run();
//# sourceMappingURL=bin.js.map
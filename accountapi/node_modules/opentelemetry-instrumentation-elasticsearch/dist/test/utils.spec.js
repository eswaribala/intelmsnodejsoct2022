"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
require("mocha");
const sinon_1 = require("sinon");
const chai_1 = require("chai");
const Utils = __importStar(require("../src/utils"));
const api_1 = require("@opentelemetry/api");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
describe('elasticsearch utils', () => {
    const spanMock = {
        recordException: (err) => { },
        setStatus: (obj) => { },
        end: () => { },
        setAttributes: (obj) => { },
    };
    context('defaultDbStatementSerializer', () => {
        it('should serialize', () => {
            const result = Utils.defaultDbStatementSerializer('operationName', { index: 'test' }, {});
            chai_1.expect(result).to.equal('{"params":{"index":"test"},"options":{}}');
        });
    });
    context('onError', () => {
        it('should record error', () => {
            const recordExceptionStub = sinon_1.stub(spanMock, 'recordException');
            const setStatusStub = sinon_1.stub(spanMock, 'setStatus');
            const endStub = sinon_1.stub(spanMock, 'end');
            const error = new Error('test error');
            // @ts-ignore
            Utils.onError(spanMock, error);
            sinon_1.assert.calledOnce(recordExceptionStub);
            sinon_1.assert.calledWith(recordExceptionStub, error);
            sinon_1.assert.calledOnce(setStatusStub);
            sinon_1.assert.calledWith(setStatusStub, { code: api_1.SpanStatusCode.ERROR, message: error.message });
            sinon_1.assert.calledOnce(endStub);
            recordExceptionStub.restore();
            setStatusStub.restore();
            endStub.restore();
        });
    });
    context('onResponse', () => {
        it('should record response without responseHook', () => {
            const setAttributesStub = sinon_1.stub(spanMock, 'setAttributes');
            const setStatusStub = sinon_1.stub(spanMock, 'setStatus');
            const endStub = sinon_1.stub(spanMock, 'end');
            // @ts-ignore
            Utils.onResponse(spanMock, { meta: { connection: { url: 'http://localhost' } } });
            sinon_1.assert.calledOnce(setAttributesStub);
            sinon_1.assert.calledOnce(setStatusStub);
            sinon_1.assert.calledOnce(endStub);
            sinon_1.assert.calledWith(setStatusStub, { code: api_1.SpanStatusCode.OK });
            setAttributesStub.restore();
            setStatusStub.restore();
            endStub.restore();
        });
        it('should record response with responseHook', () => {
            const setAttributesStub = sinon_1.stub(spanMock, 'setAttributes');
            const setStatusStub = sinon_1.stub(spanMock, 'setStatus');
            const endStub = sinon_1.stub(spanMock, 'end');
            const responseHook = sinon_1.spy();
            // @ts-ignore
            Utils.onResponse(spanMock, { meta: { connection: { url: 'http://localhost' } } }, responseHook);
            sinon_1.assert.calledOnce(setAttributesStub);
            sinon_1.assert.calledOnce(setStatusStub);
            sinon_1.assert.calledOnce(endStub);
            sinon_1.assert.calledWith(setStatusStub, { code: api_1.SpanStatusCode.OK });
            chai_1.expect(responseHook.called).to.be.true;
            setAttributesStub.restore();
            setStatusStub.restore();
            endStub.restore();
        });
    });
    context('getNetAttributes', () => {
        const url = 'http://localhost:9200';
        const attributes = Utils.getNetAttributes(url);
        it('should get hostname from url', () => {
            chai_1.expect(attributes[semantic_conventions_1.SemanticAttributes.NET_PEER_NAME]).to.equal('localhost');
        });
        it('should get hostname from url', () => {
            chai_1.expect(attributes[semantic_conventions_1.SemanticAttributes.NET_PEER_PORT]).to.equal('9200');
        });
        it('should set net.transport', () => {
            chai_1.expect(attributes[semantic_conventions_1.SemanticAttributes.NET_TRANSPORT]).to.equal('IP.TCP');
        });
    });
    context('getPort', () => {
        it('should get port', () => {
            const result = Utils.getPort('3030', 'http:');
            chai_1.expect(result).to.equal('3030');
        });
        it('should get port from http protocol', () => {
            const result = Utils.getPort('', 'http:');
            chai_1.expect(result).to.equal('80');
        });
        it('should get port from https protocol', () => {
            const result = Utils.getPort('', 'https:');
            chai_1.expect(result).to.equal('443');
        });
    });
    context('normalizeArguments', () => {
        it('should normalize with callback only', () => {
            const callbackFunction = () => { };
            // @ts-ignore
            const [params, options, callback] = Utils.normalizeArguments(callbackFunction);
            chai_1.expect(params).to.be.empty;
            chai_1.expect(options).to.be.empty;
            chai_1.expect(callback).to.be.equal(callbackFunction);
        });
        it('should normalize with params only', () => {
            // @ts-ignore
            const [params, options, callback] = Utils.normalizeArguments({ index: 'test' });
            chai_1.expect(params).to.deep.equal({ index: 'test' });
            chai_1.expect(options).to.be.undefined;
            chai_1.expect(callback).to.be.undefined;
        });
    });
    context('getIndexName', () => {
        it('should accept index string', () => {
            const index = Utils.getIndexName({ index: 'test' });
            chai_1.expect(index).to.equal('test');
        });
        it('should accept index array', () => {
            const indexes = Utils.getIndexName({ index: ['index1', 'index2'] });
            chai_1.expect(indexes).to.equal('index1,index2');
        });
        it('should accept no index', () => {
            const undefinedParams = Utils.getIndexName(undefined);
            const emptyObject = Utils.getIndexName({});
            chai_1.expect(undefinedParams).to.be.undefined;
            chai_1.expect(emptyObject).to.be.undefined;
        });
        it('should ignore unexpected index', () => {
            const functionIndex = Utils.getIndexName({ index: () => { } });
            const objectIndex = Utils.getIndexName({ index: {} });
            chai_1.expect(functionIndex).to.be.undefined;
            chai_1.expect(objectIndex).to.be.undefined;
        });
    });
    context('startSpan', () => {
        const tracerMock = {
            startSpan: (name, options, context) => { },
            startActiveSpan: () => { },
        };
        it('should start span with client kind', () => {
            const startSpanStub = sinon_1.stub(tracerMock, 'startSpan');
            Utils.startSpan({
                tracer: tracerMock,
                attributes: { testAttribute: 'testValue' },
            });
            sinon_1.assert.calledOnce(startSpanStub);
            const [operation, options] = startSpanStub.getCall(0).args;
            chai_1.expect(operation).to.equal('elasticsearch.request');
            chai_1.expect(options.kind).to.equal(api_1.SpanKind.CLIENT);
            chai_1.expect(options.attributes[semantic_conventions_1.SemanticAttributes.DB_SYSTEM]).to.equal('elasticsearch');
            chai_1.expect(options.attributes.testAttribute).to.equal('testValue');
        });
    });
});
//# sourceMappingURL=utils.spec.js.map
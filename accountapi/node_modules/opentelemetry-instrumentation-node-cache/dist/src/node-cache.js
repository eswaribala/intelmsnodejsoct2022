"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeCacheInstrumentation = void 0;
const instrumentation_1 = require("@opentelemetry/instrumentation");
const version_1 = require("./version");
const api_1 = require("@opentelemetry/api");
const core_1 = require("@opentelemetry/core");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
class NodeCacheInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(_config = {}) {
        super('opentelemetry-instrumentation-node-cache', version_1.VERSION, _config);
        this._config = _config;
    }
    setConfig(config = {}) {
        this._config = config;
    }
    init() {
        const module = new instrumentation_1.InstrumentationNodeModuleDefinition('node-cache', ['>=5.0.0'], this.patch.bind(this));
        return module;
    }
    patch(moduleExports, moduleVersion) {
        const self = this;
        const origConstructor = moduleExports;
        const origPrototype = moduleExports.prototype;
        function PatchedNodeCache(options = {}) {
            const inst = new origConstructor(options);
            ['get', 'take', 'del', 'getTtl', 'has', 'set', 'mget', 'flushAll'].forEach((op) => self._wrap(inst, op, self
                .patchClassFunction(op, (args) => `${op} ${args[0] ? args[0] : ''}`.trim(), moduleVersion)
                .bind(self)));
            self._wrap(inst, 'mset', self
                .patchClassFunction('mset', (args) => `mset ${args[0].map((entry) => entry.key).join(',')}`, moduleVersion)
                .bind(self));
            self._wrap(inst, 'ttl', self.patchClassFunction('ttl', (args) => `ttl ${args[0]} ${args[1]}`, moduleVersion).bind(self));
            return inst;
        }
        PatchedNodeCache.prototype = origPrototype;
        PatchedNodeCache.version = moduleExports.version;
        return PatchedNodeCache;
    }
    patchClassFunction(opName, toStatement, moduleVersion) {
        const self = this;
        return (originalFunc) => {
            return function func() {
                if (self._config.requireParentSpan && api_1.trace.getSpan(api_1.context.active()) === undefined) {
                    return originalFunc.apply(this, arguments);
                }
                const span = self.tracer.startSpan(`node-cache ${opName}`, {
                    kind: api_1.SpanKind.INTERNAL,
                    attributes: {
                        [semantic_conventions_1.SemanticAttributes.DB_SYSTEM]: 'node-cache',
                        [semantic_conventions_1.SemanticAttributes.DB_OPERATION]: opName,
                        [semantic_conventions_1.SemanticAttributes.DB_STATEMENT]: toStatement(arguments),
                    },
                });
                if (self._config.requestHook) {
                    try {
                        self._config.requestHook(span, {
                            moduleVersion,
                            operation: opName,
                            args: Object.values(arguments),
                        });
                    }
                    catch (err) {
                        api_1.diag.error('node-cache instrumentation: requestHook error', err);
                    }
                }
                try {
                    // Some operations, like "take", use other operation under the hood
                    // We're only interested in the top level operation, so we use "suppressTracing"
                    const response = api_1.context.with(core_1.suppressTracing(api_1.context.active()), () => originalFunc.apply(this, arguments));
                    if (self._config.responseHook) {
                        try {
                            self._config.responseHook(span, { operation: opName, response });
                        }
                        catch (err) {
                            api_1.diag.error('node-cache instrumentation: responseHook error', err);
                        }
                    }
                    return response;
                }
                catch (err) {
                    span.recordException(err);
                    span.setStatus({
                        code: api_1.SpanStatusCode.ERROR,
                        message: typeof err === 'string' ? err : err === null || err === void 0 ? void 0 : err.message,
                    });
                    throw err;
                }
                finally {
                    span.end();
                }
            };
        };
    }
}
exports.NodeCacheInstrumentation = NodeCacheInstrumentation;
//# sourceMappingURL=node-cache.js.map
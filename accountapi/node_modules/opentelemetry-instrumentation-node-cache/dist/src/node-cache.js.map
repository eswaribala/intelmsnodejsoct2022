{"version":3,"file":"node-cache.js","sourceRoot":"","sources":["../../src/node-cache.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as NodeCache from 'node-cache';\nimport {\n    InstrumentationBase,\n    InstrumentationModuleDefinition,\n    InstrumentationNodeModuleDefinition,\n} from '@opentelemetry/instrumentation';\nimport { NodeCacheInstrumentationConfig } from './types';\nimport { VERSION } from './version';\nimport { diag, SpanKind, SpanStatusCode, context, trace } from '@opentelemetry/api';\nimport { suppressTracing } from '@opentelemetry/core';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\n\ntype NodeCacheType = typeof NodeCache;\n\nexport class NodeCacheInstrumentation extends InstrumentationBase<NodeCacheType> {\n    constructor(protected override _config: NodeCacheInstrumentationConfig = {}) {\n        super('opentelemetry-instrumentation-node-cache', VERSION, _config);\n    }\n\n    override setConfig(config: NodeCacheInstrumentationConfig = {}) {\n        this._config = config;\n    }\n\n    protected init(): InstrumentationModuleDefinition<NodeCacheType> {\n        const module = new InstrumentationNodeModuleDefinition<NodeCacheType>(\n            'node-cache',\n            ['>=5.0.0'],\n            this.patch.bind(this)\n        );\n        return module;\n    }\n\n    private patch(moduleExports: NodeCacheType, moduleVersion: string) {\n        const self = this;\n        const origConstructor = moduleExports as unknown as Function;\n        const origPrototype = moduleExports.prototype;\n\n        function PatchedNodeCache(options = {}) {\n            const inst: NodeCache = new (origConstructor as any)(options);\n            ['get', 'take', 'del', 'getTtl', 'has', 'set', 'mget', 'flushAll'].forEach((op) =>\n                self._wrap(\n                    inst,\n                    op as keyof NodeCache,\n                    self\n                        .patchClassFunction(\n                            op,\n                            (args: any[]) => `${op} ${args[0] ? args[0] : ''}`.trim(),\n                            moduleVersion\n                        )\n                        .bind(self)\n                )\n            );\n            self._wrap(\n                inst,\n                'mset',\n                self\n                    .patchClassFunction(\n                        'mset',\n                        (args: any[]) => `mset ${args[0].map((entry: NodeCache.ValueSetItem) => entry.key).join(',')}`,\n                        moduleVersion\n                    )\n                    .bind(self)\n            );\n            self._wrap(\n                inst,\n                'ttl',\n                self.patchClassFunction('ttl', (args: any[]) => `ttl ${args[0]} ${args[1]}`, moduleVersion).bind(self)\n            );\n            return inst;\n        }\n        PatchedNodeCache.prototype = origPrototype;\n        PatchedNodeCache.version = (moduleExports as any).version;\n        return PatchedNodeCache;\n    }\n\n    private patchClassFunction(opName: string, toStatement: (...args: any[]) => string, moduleVersion: string) {\n        const self = this;\n        return (originalFunc: Function) => {\n            return function func() {\n                if (self._config.requireParentSpan && trace.getSpan(context.active()) === undefined) {\n                    return originalFunc.apply(this, arguments);\n                }\n\n                const span = self.tracer.startSpan(`node-cache ${opName}`, {\n                    kind: SpanKind.INTERNAL,\n                    attributes: {\n                        [SemanticAttributes.DB_SYSTEM]: 'node-cache',\n                        [SemanticAttributes.DB_OPERATION]: opName,\n                        [SemanticAttributes.DB_STATEMENT]: toStatement(arguments),\n                    },\n                });\n\n                if (self._config.requestHook) {\n                    try {\n                        self._config.requestHook(span, {\n                            moduleVersion,\n                            operation: opName,\n                            args: Object.values(arguments),\n                        });\n                    } catch (err) {\n                        diag.error('node-cache instrumentation: requestHook error', err);\n                    }\n                }\n\n                try {\n                    // Some operations, like \"take\", use other operation under the hood\n                    // We're only interested in the top level operation, so we use \"suppressTracing\"\n                    const response = context.with(suppressTracing(context.active()), () =>\n                        originalFunc.apply(this, arguments)\n                    );\n                    if (self._config.responseHook) {\n                        try {\n                            self._config.responseHook(span, { operation: opName, response });\n                        } catch (err) {\n                            diag.error('node-cache instrumentation: responseHook error', err);\n                        }\n                    }\n                    return response;\n                } catch (err) {\n                    span.recordException(err);\n                    span.setStatus({\n                        code: SpanStatusCode.ERROR,\n                        message: typeof err === 'string' ? err : err?.message,\n                    });\n                    throw err;\n                } finally {\n                    span.end();\n                }\n            };\n        };\n    }\n}\n"]}
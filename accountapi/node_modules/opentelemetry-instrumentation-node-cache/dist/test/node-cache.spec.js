"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require("mocha");
const expect_1 = __importDefault(require("expect"));
const contrib_test_utils_1 = require("@opentelemetry/contrib-test-utils");
const src_1 = require("../src");
const api_1 = require("@opentelemetry/api");
const DB_RESPONSE = 'db.response';
const instrumentation = contrib_test_utils_1.registerInstrumentationTesting(new src_1.NodeCacheInstrumentation());
instrumentation.enable();
const node_cache_1 = __importDefault(require("node-cache"));
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
describe('node-cache instrumentation', () => {
    let cache = new node_cache_1.default();
    const getSingleSpan = () => {
        const spans = contrib_test_utils_1.getTestSpans();
        expect_1.default(spans.length).toBe(1);
        return spans[0];
    };
    beforeEach(async () => {
        contrib_test_utils_1.resetMemoryExporter();
        cache = new node_cache_1.default();
        instrumentation.setConfig({
            responseHook: (span, { response }) => span.setAttribute(DB_RESPONSE, typeof response === 'object' ? JSON.stringify(response) : response),
        });
        instrumentation.enable();
    });
    afterEach(async () => {
        instrumentation.disable();
    });
    describe('instruments functions', () => {
        it('set', () => {
            cache.set('some-key', 'cool');
            const span = getSingleSpan();
            expect_1.default(span.name).toBe('node-cache set');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_SYSTEM]).toBe('node-cache');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('set');
            expect_1.default(span.attributes[DB_RESPONSE]).toBe(true);
        });
        it('get', () => {
            cache.set('some-key', 'some-value');
            contrib_test_utils_1.resetMemoryExporter();
            cache.get('some-key');
            const span = getSingleSpan();
            expect_1.default(span.name).toBe('node-cache get');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_SYSTEM]).toBe('node-cache');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('get');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_STATEMENT]).toBe('get some-key');
            expect_1.default(span.attributes[DB_RESPONSE]).toBe('some-value');
        });
        it('has', () => {
            cache.has('some-key');
            const span = getSingleSpan();
            expect_1.default(span.name).toBe('node-cache has');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_SYSTEM]).toBe('node-cache');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('has');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_STATEMENT]).toBe('has some-key');
            expect_1.default(span.attributes[DB_RESPONSE]).toBe(false);
        });
        it('take', () => {
            cache.set('some-key', 'some-value');
            contrib_test_utils_1.resetMemoryExporter();
            // Does not exist on versions <= 5.1.1, need to hack this
            if (!cache['take'])
                return;
            cache['take']('some-key');
            const span = getSingleSpan();
            expect_1.default(span.name).toBe('node-cache take');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_SYSTEM]).toBe('node-cache');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('take');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_STATEMENT]).toBe('take some-key');
            expect_1.default(span.attributes[DB_RESPONSE]).toBe('some-value');
        });
        it('del', () => {
            cache.set('some-key', 'some-value');
            contrib_test_utils_1.resetMemoryExporter();
            cache.del('some-key');
            const span = getSingleSpan();
            expect_1.default(span.name).toBe('node-cache del');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_SYSTEM]).toBe('node-cache');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('del');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_STATEMENT]).toBe('del some-key');
            expect_1.default(span.attributes[DB_RESPONSE]).toBe(1);
        });
        it('mdel', () => {
            cache.set('some-key', 'some-value');
            cache.set('some-other-key', 'some-value');
            contrib_test_utils_1.resetMemoryExporter();
            cache.del(['some-key', 'some-other-key']);
            const span = getSingleSpan();
            expect_1.default(span.name).toBe('node-cache del');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_SYSTEM]).toBe('node-cache');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('del');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_STATEMENT]).toBe('del some-key,some-other-key');
            expect_1.default(span.attributes[DB_RESPONSE]).toBe(2);
        });
        it('mget', () => {
            cache.set('a', 'x');
            cache.set('b', 'y');
            contrib_test_utils_1.resetMemoryExporter();
            const res = cache.mget(['a', 'b', 'c']);
            expect_1.default(res).toEqual({ a: 'x', b: 'y' });
            const span = getSingleSpan();
            expect_1.default(span.name).toBe('node-cache mget');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_SYSTEM]).toBe('node-cache');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('mget');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_STATEMENT]).toBe('mget a,b,c');
            expect_1.default(JSON.parse(span.attributes[DB_RESPONSE])).toEqual({ a: 'x', b: 'y' });
        });
        it('mset', () => {
            cache.mset([
                { key: 'a', val: 'x' },
                { key: 'b', val: 'y' },
            ]);
            const span = getSingleSpan();
            expect_1.default(span.name).toBe('node-cache mset');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_SYSTEM]).toBe('node-cache');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('mset');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_STATEMENT]).toBe('mset a,b');
            expect_1.default(span.attributes[DB_RESPONSE]).toEqual(true);
        });
        it('getTtl', () => {
            cache.getTtl('some-key');
            const span = getSingleSpan();
            expect_1.default(span.name).toBe('node-cache getTtl');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_SYSTEM]).toBe('node-cache');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('getTtl');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_STATEMENT]).toBe('getTtl some-key');
        });
        it('ttl', () => {
            cache.ttl('some-key', 12345);
            const span = getSingleSpan();
            expect_1.default(span.name).toBe('node-cache ttl');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_SYSTEM]).toBe('node-cache');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('ttl');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_STATEMENT]).toBe('ttl some-key 12345');
        });
        it('flushAll', () => {
            cache.flushAll();
            const span = getSingleSpan();
            expect_1.default(span.name).toBe('node-cache flushAll');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_SYSTEM]).toBe('node-cache');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION]).toBe('flushAll');
            expect_1.default(span.attributes[semantic_conventions_1.SemanticAttributes.DB_STATEMENT]).toBe('flushAll');
        });
    });
    describe('requireParentSpan', () => {
        beforeEach(() => {
            instrumentation.disable();
            instrumentation.setConfig({
                requireParentSpan: true,
            });
            instrumentation.enable();
        });
        it('should not start span on node-cache method', () => {
            api_1.context.with(api_1.ROOT_CONTEXT, () => {
                cache.get('test');
            });
            const spans = contrib_test_utils_1.getTestSpans();
            expect_1.default(spans.length).toBe(0);
        });
    });
    describe('moduleVersionAttributeName', () => {
        const VERSION_ATTR_NAME = 'ver';
        beforeEach(() => {
            instrumentation.disable();
            instrumentation.setConfig({
                requestHook: (span, { moduleVersion }) => {
                    span.setAttribute(VERSION_ATTR_NAME, moduleVersion);
                },
            });
            instrumentation.enable();
        });
        it('should not start span on node-cache method', () => {
            cache.get('test');
            const span = getSingleSpan();
            expect_1.default(span.attributes[VERSION_ATTR_NAME]).toBeDefined();
        });
    });
    describe('requestHook', () => {
        beforeEach(() => {
            instrumentation.disable();
            instrumentation.setConfig({
                requestHook: (span, { operation, args }) => {
                    if (operation === 'set') {
                        span.setAttribute('db.payload', JSON.stringify({ value: args[1], ttl: args[2] }));
                    }
                    if (operation === 'mset') {
                        span.setAttribute('db.payload', JSON.stringify(args[0]));
                    }
                },
            });
            instrumentation.enable();
        });
        it('captures set payload using requestHook', () => {
            cache.set('some-key', 'some-value', 12345);
            const span = getSingleSpan();
            expect_1.default(span.attributes['db.payload']).toBe('{"value":"some-value","ttl":12345}');
        });
        it('captures mset payload using requestHook', () => {
            cache.mset([{ key: 'some-key', val: 'some-val', ttl: 12345 }]);
            const span = getSingleSpan();
            expect_1.default(span.attributes['db.payload']).toBe('[{"key":"some-key","val":"some-val","ttl":12345}]');
        });
    });
});
//# sourceMappingURL=node-cache.spec.js.map